{"version":3,"sources":["turbopack:///[project]/app/reservations/actions.ts","turbopack:///[project]/lib/reservations/data.ts","turbopack:///[project]/lib/reservations/sms.ts","turbopack:///[project]/lib/reservations/utils.ts"],"sourcesContent":["'use server';\n\nimport { revalidatePath } from 'next/cache';\nimport { \n  createReservation,\n  updateReservation,\n  cancelReservation,\n  addToWaitlist,\n  updateWaitlistEntry,\n  updateTableStatus,\n  getGuests,\n  getTables,\n  getReservations\n} from '@/lib/reservations/data';\nimport { \n  CreateReservationData,\n  UpdateReservationData,\n  CreateWaitlistEntryData,\n  TableStatus,\n  WaitlistStatus,\n  ApiResponse,\n  Reservation,\n  WaitlistEntry,\n  Table,\n  Guest\n} from '@/lib/reservations/types';\nimport { smsService } from '@/lib/reservations/sms';\nimport { validateReservationData, validateGuestData } from '@/lib/reservations/utils';\n\n// Reservation Actions\nexport async function createReservationAction(data: CreateReservationData): Promise<ApiResponse<Reservation>> {\n  try {\n    // Validate input data\n    const validationErrors = validateReservationData(data);\n    if (validationErrors.length > 0) {\n      return {\n        success: false,\n        error: validationErrors.join(', ')\n      };\n    }\n\n    // Create the reservation\n    const result = await createReservation(data);\n    \n    if (result.success && result.data) {\n      // Send confirmation SMS if guest info is provided\n      if (data.guest?.phone || data.guestId) {\n        try {\n          let guest: Guest | null = null;\n          \n          if (data.guestId) {\n            const guests = await getGuests();\n            guest = guests.find(g => g.id === data.guestId) || null;\n          } else if (data.guest) {\n            // Create a temporary guest object for SMS\n            guest = {\n              id: 'temp',\n              firstName: data.guest.firstName,\n              lastName: data.guest.lastName,\n              phone: data.guest.phone,\n              email: data.guest.email,\n              preferences: {},\n              visitHistory: [],\n              totalVisits: 0,\n              totalSpent: 0,\n              averageSpend: 0,\n              vipStatus: 'regular',\n              createdAt: new Date().toISOString(),\n              updatedAt: new Date().toISOString()\n            } as Guest;\n          }\n          \n          if (guest) {\n            await smsService.sendReservationConfirmation(result.data, guest);\n          }\n        } catch (smsError) {\n          console.error('Failed to send reservation confirmation SMS:', smsError);\n          // Don't fail the reservation creation if SMS fails\n        }\n      }\n      \n      revalidatePath('/reservations');\n    }\n    \n    return result;\n  } catch (error) {\n    console.error('Create reservation error:', error);\n    return {\n      success: false,\n      error: 'Failed to create reservation. Please try again.'\n    };\n  }\n}\n\nexport async function updateReservationAction(\n  id: string, \n  data: UpdateReservationData\n): Promise<ApiResponse<Reservation>> {\n  try {\n    const result = await updateReservation(id, data);\n    \n    if (result.success) {\n      revalidatePath('/reservations');\n    }\n    \n    return result;\n  } catch (error) {\n    console.error('Update reservation error:', error);\n    return {\n      success: false,\n      error: 'Failed to update reservation. Please try again.'\n    };\n  }\n}\n\nexport async function cancelReservationAction(id: string, reason?: string): Promise<ApiResponse<void>> {\n  try {\n    // Get reservation and guest info for SMS notification\n    const reservationsResponse = await getReservations();\n    const reservation = reservationsResponse.data.find(r => r.id === id);\n    \n    const result = await cancelReservation(id);\n    \n    if (result.success && reservation) {\n      // Send cancellation notification\n      try {\n        const guests = await getGuests();\n        const guest = guests.find(g => g.id === reservation.guestId);\n        \n        if (guest) {\n          await smsService.sendReservationCancellation(reservation, guest);\n        }\n      } catch (smsError) {\n        console.error('Failed to send cancellation SMS:', smsError);\n      }\n      \n      revalidatePath('/reservations');\n    }\n    \n    return result;\n  } catch (error) {\n    console.error('Cancel reservation error:', error);\n    return {\n      success: false,\n      error: 'Failed to cancel reservation. Please try again.'\n    };\n  }\n}\n\nexport async function seatReservationAction(\n  reservationId: string,\n  tableId: string\n): Promise<ApiResponse<Reservation>> {\n  try {\n    // Update reservation status to seated\n    const result = await updateReservation(reservationId, {\n      status: 'seated',\n      tableId: tableId\n    });\n    \n    if (result.success) {\n      // Update table status to occupied\n      await updateTableStatus(tableId, 'occupied');\n      revalidatePath('/reservations');\n    }\n    \n    return result;\n  } catch (error) {\n    console.error('Seat reservation error:', error);\n    return {\n      success: false,\n      error: 'Failed to seat reservation. Please try again.'\n    };\n  }\n}\n\nexport async function completeReservationAction(\n  reservationId: string,\n  tableId?: string\n): Promise<ApiResponse<Reservation>> {\n  try {\n    const result = await updateReservation(reservationId, {\n      status: 'completed'\n    });\n    \n    if (result.success && tableId) {\n      // Update table status to cleaning\n      await updateTableStatus(tableId, 'cleaning');\n      revalidatePath('/reservations');\n    }\n    \n    return result;\n  } catch (error) {\n    console.error('Complete reservation error:', error);\n    return {\n      success: false,\n      error: 'Failed to complete reservation. Please try again.'\n    };\n  }\n}\n\nexport async function markNoShowAction(reservationId: string): Promise<ApiResponse<Reservation>> {\n  try {\n    const result = await updateReservation(reservationId, {\n      status: 'no-show'\n    });\n    \n    if (result.success) {\n      // Send follow-up SMS for no-show\n      try {\n        const reservationsResponse = await getReservations();\n        const reservation = reservationsResponse.data.find(r => r.id === reservationId);\n        \n        if (reservation) {\n          const guests = await getGuests();\n          const guest = guests.find(g => g.id === reservation.guestId);\n          \n          if (guest) {\n            // Schedule follow-up SMS (could be sent immediately or delayed)\n            setTimeout(async () => {\n              try {\n                await smsService.sendNoShowFollowUp(reservation, guest);\n              } catch (error) {\n                console.error('No-show follow-up SMS error:', error);\n              }\n            }, 60000); // Wait 1 minute\n          }\n        }\n      } catch (smsError) {\n        console.error('Failed to schedule no-show follow-up:', smsError);\n      }\n      \n      revalidatePath('/reservations');\n    }\n    \n    return result;\n  } catch (error) {\n    console.error('Mark no-show error:', error);\n    return {\n      success: false,\n      error: 'Failed to mark reservation as no-show. Please try again.'\n    };\n  }\n}\n\n// Waitlist Actions\nexport async function addToWaitlistAction(data: CreateWaitlistEntryData): Promise<ApiResponse<WaitlistEntry>> {\n  try {\n    // Validate guest data if provided\n    if (data.guest) {\n      const validationErrors = validateGuestData(data.guest);\n      if (validationErrors.length > 0) {\n        return {\n          success: false,\n          error: validationErrors.join(', ')\n        };\n      }\n    }\n\n    const result = await addToWaitlist(data);\n    \n    if (result.success) {\n      revalidatePath('/reservations');\n    }\n    \n    return result;\n  } catch (error) {\n    console.error('Add to waitlist error:', error);\n    return {\n      success: false,\n      error: 'Failed to add to waitlist. Please try again.'\n    };\n  }\n}\n\nexport async function updateWaitlistEntryAction(\n  id: string,\n  status: WaitlistStatus\n): Promise<ApiResponse<WaitlistEntry>> {\n  try {\n    const result = await updateWaitlistEntry(id, status);\n    \n    if (result.success && result.data) {\n      // Send SMS notification based on status change\n      try {\n        const guests = await getGuests();\n        const guest = guests.find(g => g.id === result.data!.guestId);\n        \n        if (guest && status === 'notified') {\n          await smsService.sendTableReadyNotification(result.data, guest);\n        }\n      } catch (smsError) {\n        console.error('Failed to send waitlist notification:', smsError);\n      }\n      \n      revalidatePath('/reservations');\n    }\n    \n    return result;\n  } catch (error) {\n    console.error('Update waitlist entry error:', error);\n    return {\n      success: false,\n      error: 'Failed to update waitlist entry. Please try again.'\n    };\n  }\n}\n\nexport async function seatFromWaitlistAction(\n  waitlistId: string,\n  tableId: string\n): Promise<ApiResponse<{ waitlistEntry: WaitlistEntry; reservation: Reservation }>> {\n  try {\n    // Update waitlist entry to seated\n    const waitlistResult = await updateWaitlistEntry(waitlistId, 'seated');\n    \n    if (waitlistResult.success && waitlistResult.data) {\n      // Create a reservation for the waitlist entry\n      const reservationData: CreateReservationData = {\n        guestId: waitlistResult.data.guestId,\n        partySize: waitlistResult.data.partySize,\n        dateTime: new Date().toISOString(),\n        duration: 120, // Default 2 hours\n        source: 'walk-in'\n      };\n      \n      const reservationResult = await createReservation(reservationData);\n      \n      if (reservationResult.success && reservationResult.data) {\n        // Seat the reservation immediately\n        await updateReservation(reservationResult.data.id, {\n          status: 'seated',\n          tableId: tableId\n        });\n        \n        // Update table status\n        await updateTableStatus(tableId, 'occupied');\n        \n        revalidatePath('/reservations');\n        \n        return {\n          success: true,\n          data: {\n            waitlistEntry: waitlistResult.data,\n            reservation: reservationResult.data\n          },\n          message: 'Guest seated successfully from waitlist'\n        };\n      }\n    }\n    \n    return {\n      success: false,\n      error: 'Failed to seat guest from waitlist'\n    };\n  } catch (error) {\n    console.error('Seat from waitlist error:', error);\n    return {\n      success: false,\n      error: 'Failed to seat guest from waitlist. Please try again.'\n    };\n  }\n}\n\n// Table Management Actions\nexport async function updateTableStatusAction(\n  tableId: string,\n  status: TableStatus\n): Promise<ApiResponse<Table>> {\n  try {\n    const result = await updateTableStatus(tableId, status);\n    \n    if (result.success) {\n      revalidatePath('/reservations');\n    }\n    \n    return result;\n  } catch (error) {\n    console.error('Update table status error:', error);\n    return {\n      success: false,\n      error: 'Failed to update table status. Please try again.'\n    };\n  }\n}\n\nexport async function combineTablesAction(\n  tableIds: string[],\n  combinationName: string\n): Promise<ApiResponse<Table[]>> {\n  try {\n    if (tableIds.length < 2) {\n      return {\n        success: false,\n        error: 'At least 2 tables are required for combination'\n      };\n    }\n\n    // Get all tables to validate\n    const allTables = await getTables();\n    const tablesToCombine = allTables.filter(table => tableIds.includes(table.id));\n    \n    // Validate tables can be combined\n    const canCombine = tablesToCombine.every(table => \n      table.isCombinable && \n      table.status === 'available' &&\n      table.diningAreaId === tablesToCombine[0].diningAreaId\n    );\n    \n    if (!canCombine) {\n      return {\n        success: false,\n        error: 'Selected tables cannot be combined. Check that all tables are available and combinable.'\n      };\n    }\n\n    // Update all tables to combined status\n    const updatePromises = tableIds.map(id => updateTableStatus(id, 'combined'));\n    const results = await Promise.all(updatePromises);\n    \n    const updatedTables = results\n      .filter(result => result.success && result.data)\n      .map(result => result.data!);\n    \n    if (updatedTables.length === tableIds.length) {\n      revalidatePath('/reservations');\n      return {\n        success: true,\n        data: updatedTables,\n        message: `Tables combined successfully as \"${combinationName}\"`\n      };\n    } else {\n      return {\n        success: false,\n        error: 'Failed to combine some tables'\n      };\n    }\n  } catch (error) {\n    console.error('Combine tables error:', error);\n    return {\n      success: false,\n      error: 'Failed to combine tables. Please try again.'\n    };\n  }\n}\n\nexport async function separateTablesAction(tableIds: string[]): Promise<ApiResponse<Table[]>> {\n  try {\n    // Update all tables back to available status\n    const updatePromises = tableIds.map(id => updateTableStatus(id, 'available'));\n    const results = await Promise.all(updatePromises);\n    \n    const updatedTables = results\n      .filter(result => result.success && result.data)\n      .map(result => result.data!);\n    \n    if (updatedTables.length === tableIds.length) {\n      revalidatePath('/reservations');\n      return {\n        success: true,\n        data: updatedTables,\n        message: 'Tables separated successfully'\n      };\n    } else {\n      return {\n        success: false,\n        error: 'Failed to separate some tables'\n      };\n    }\n  } catch (error) {\n    console.error('Separate tables error:', error);\n    return {\n      success: false,\n      error: 'Failed to separate tables. Please try again.'\n    };\n  }\n}\n\n// Batch Operations\nexport async function batchUpdateReservationsAction(\n  updates: { id: string; data: Partial<UpdateReservationData> }[]\n): Promise<ApiResponse<{ successful: string[]; failed: string[] }>> {\n  try {\n    const results = await Promise.allSettled(\n      updates.map(update => updateReservation(update.id, update.data))\n    );\n    \n    const successful: string[] = [];\n    const failed: string[] = [];\n    \n    results.forEach((result, index) => {\n      if (result.status === 'fulfilled' && result.value.success) {\n        successful.push(updates[index].id);\n      } else {\n        failed.push(updates[index].id);\n      }\n    });\n    \n    if (successful.length > 0) {\n      revalidatePath('/reservations');\n    }\n    \n    return {\n      success: true,\n      data: { successful, failed },\n      message: `Updated ${successful.length} reservations successfully`\n    };\n  } catch (error) {\n    console.error('Batch update reservations error:', error);\n    return {\n      success: false,\n      error: 'Failed to update reservations. Please try again.'\n    };\n  }\n}\n\nexport async function sendBulkRemindersAction(reservationIds: string[]): Promise<ApiResponse<{ sent: number; failed: number }>> {\n  try {\n    const reservationsResponse = await getReservations();\n    const reservations = reservationsResponse.data.filter(r => reservationIds.includes(r.id));\n    const guests = await getGuests();\n    \n    const reservationGuestPairs = reservations.map(reservation => {\n      const guest = guests.find(g => g.id === reservation.guestId);\n      return guest ? { reservation, guest } : null;\n    }).filter(Boolean) as { reservation: Reservation; guest: Guest }[];\n    \n    const notifications = await smsService.sendBulkReminders(reservationGuestPairs);\n    \n    return {\n      success: true,\n      data: {\n        sent: notifications.filter(n => n.status === 'sent').length,\n        failed: notifications.filter(n => n.status === 'failed').length\n      },\n      message: `Sent ${notifications.length} reminder notifications`\n    };\n  } catch (error) {\n    console.error('Send bulk reminders error:', error);\n    return {\n      success: false,\n      error: 'Failed to send reminder notifications. Please try again.'\n    };\n  }\n}\n\n// Real-time Actions\nexport async function subscribeToRealtimeUpdatesAction() {\n  // This would typically set up WebSocket connections or Server-Sent Events\n  // For now, we'll use the polling mechanism from the data layer\n  \n  // The actual real-time subscription would be handled on the client side\n  // using the subscribeToUpdates function from the data layer\n  \n  return {\n    success: true,\n    message: 'Real-time updates subscription initiated'\n  };\n}","import { \n  Table, \n  DiningArea, \n  Reservation, \n  Guest, \n  WaitlistEntry, \n  FloorPlan,\n  ReservationStats,\n  AvailabilityWindow,\n  TableTurnover,\n  ReservationFilters,\n  WaitlistFilters,\n  CreateReservationData,\n  UpdateReservationData,\n  CreateWaitlistEntryData,\n  ApiResponse,\n  PaginatedResponse,\n  TableStatus,\n  ReservationStatus,\n  WaitlistStatus,\n  VIPStatus\n} from './types';\n\n// Mock Data\nexport const mockTables: Table[] = [\n  {\n    id: 'table-1',\n    number: '1',\n    capacity: 2,\n    x: 100,\n    y: 150,\n    width: 80,\n    height: 80,\n    shape: 'round',\n    status: 'available',\n    diningAreaId: 'main-dining',\n    isCombinable: false,\n    estimatedTurnoverTime: 90\n  },\n  {\n    id: 'table-2',\n    number: '2',\n    capacity: 4,\n    x: 200,\n    y: 150,\n    width: 120,\n    height: 80,\n    shape: 'rectangular',\n    status: 'occupied',\n    diningAreaId: 'main-dining',\n    isCombinable: true,\n    estimatedTurnoverTime: 120\n  },\n  {\n    id: 'table-3',\n    number: '3',\n    capacity: 4,\n    x: 350,\n    y: 150,\n    width: 120,\n    height: 80,\n    shape: 'rectangular',\n    status: 'reserved',\n    diningAreaId: 'main-dining',\n    isCombinable: true,\n    estimatedTurnoverTime: 120\n  },\n  {\n    id: 'table-4',\n    number: '4',\n    capacity: 6,\n    x: 100,\n    y: 300,\n    width: 140,\n    height: 100,\n    shape: 'rectangular',\n    status: 'cleaning',\n    diningAreaId: 'main-dining',\n    isCombinable: false,\n    estimatedTurnoverTime: 150\n  },\n  {\n    id: 'table-5',\n    number: '5',\n    capacity: 2,\n    x: 500,\n    y: 100,\n    width: 80,\n    height: 80,\n    shape: 'round',\n    status: 'available',\n    diningAreaId: 'patio',\n    isCombinable: false,\n    estimatedTurnoverTime: 90\n  }\n];\n\nexport const mockDiningAreas: DiningArea[] = [\n  {\n    id: 'main-dining',\n    name: 'Main Dining Room',\n    floor: 1,\n    capacity: 60,\n    isActive: true,\n    tables: mockTables.filter(t => t.diningAreaId === 'main-dining'),\n    layout: {\n      width: 800,\n      height: 600\n    }\n  },\n  {\n    id: 'patio',\n    name: 'Outdoor Patio',\n    floor: 1,\n    capacity: 24,\n    isActive: true,\n    tables: mockTables.filter(t => t.diningAreaId === 'patio'),\n    layout: {\n      width: 600,\n      height: 400\n    }\n  },\n  {\n    id: 'private-dining',\n    name: 'Private Dining Room',\n    floor: 2,\n    capacity: 16,\n    isActive: true,\n    tables: [],\n    layout: {\n      width: 400,\n      height: 300\n    }\n  }\n];\n\nexport const mockGuests: Guest[] = [\n  {\n    id: 'guest-1',\n    firstName: 'John',\n    lastName: 'Smith',\n    phone: '+1234567890',\n    email: 'john.smith@email.com',\n    dateOfBirth: '1985-06-15',\n    preferences: {\n      seatingPreference: 'booth',\n      dietaryRestrictions: ['gluten-free'],\n      favoriteItems: ['Caesar Salad', 'Grilled Salmon']\n    },\n    visitHistory: [],\n    totalVisits: 12,\n    totalSpent: 1250.00,\n    averageSpend: 104.17,\n    lastVisit: '2024-01-10',\n    vipStatus: 'frequent',\n    createdAt: '2023-01-15T10:00:00Z',\n    updatedAt: '2024-01-10T20:30:00Z'\n  },\n  {\n    id: 'guest-2',\n    firstName: 'Sarah',\n    lastName: 'Johnson',\n    phone: '+1987654321',\n    email: 'sarah.j@email.com',\n    anniversary: '2020-03-14',\n    preferences: {\n      seatingPreference: 'patio',\n      allergies: ['nuts'],\n      ambiance: 'quiet'\n    },\n    visitHistory: [],\n    totalVisits: 5,\n    totalSpent: 425.00,\n    averageSpend: 85.00,\n    lastVisit: '2024-01-08',\n    vipStatus: 'regular',\n    createdAt: '2023-06-20T14:00:00Z',\n    updatedAt: '2024-01-08T19:45:00Z'\n  }\n];\n\nexport const mockReservations: Reservation[] = [\n  {\n    id: 'res-1',\n    guestId: 'guest-1',\n    tableId: 'table-3',\n    partySize: 4,\n    dateTime: '2024-01-20T19:00:00Z',\n    duration: 120,\n    status: 'confirmed',\n    specialRequests: 'Window seat preferred',\n    occasion: 'birthday',\n    createdAt: '2024-01-15T10:00:00Z',\n    updatedAt: '2024-01-15T10:00:00Z',\n    source: 'online',\n    estimatedSpend: 200,\n    tags: ['birthday', 'vip']\n  },\n  {\n    id: 'res-2',\n    guestId: 'guest-2',\n    partySize: 2,\n    dateTime: '2024-01-20T20:00:00Z',\n    duration: 90,\n    status: 'pending',\n    occasion: 'anniversary',\n    createdAt: '2024-01-18T14:30:00Z',\n    updatedAt: '2024-01-18T14:30:00Z',\n    source: 'phone',\n    estimatedSpend: 150\n  }\n];\n\nexport const mockWaitlist: WaitlistEntry[] = [\n  {\n    id: 'wait-1',\n    guestId: 'guest-1',\n    partySize: 3,\n    estimatedWaitTime: 25,\n    priority: 'normal',\n    addedAt: '2024-01-20T18:30:00Z',\n    phoneNumber: '+1234567890',\n    status: 'waiting',\n    quotedWaitTime: 30\n  },\n  {\n    id: 'wait-2',\n    guestId: 'guest-2',\n    partySize: 2,\n    estimatedWaitTime: 15,\n    priority: 'vip',\n    addedAt: '2024-01-20T18:45:00Z',\n    phoneNumber: '+1987654321',\n    status: 'notified',\n    quotedWaitTime: 20\n  }\n];\n\n// API Functions\nexport async function getDiningAreas(): Promise<DiningArea[]> {\n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 300));\n  return mockDiningAreas;\n}\n\nexport async function getTables(diningAreaId?: string): Promise<Table[]> {\n  await new Promise(resolve => setTimeout(resolve, 200));\n  return diningAreaId \n    ? mockTables.filter(table => table.diningAreaId === diningAreaId)\n    : mockTables;\n}\n\nexport async function getReservations(filters?: ReservationFilters): Promise<PaginatedResponse<Reservation>> {\n  await new Promise(resolve => setTimeout(resolve, 400));\n  \n  let filteredReservations = [...mockReservations];\n  \n  if (filters) {\n    if (filters.date) {\n      filteredReservations = filteredReservations.filter(res => \n        res.dateTime.startsWith(filters.date!)\n      );\n    }\n    \n    if (filters.status?.length) {\n      filteredReservations = filteredReservations.filter(res => \n        filters.status!.includes(res.status)\n      );\n    }\n    \n    if (filters.partySize) {\n      const { min, max } = filters.partySize;\n      filteredReservations = filteredReservations.filter(res => {\n        if (min && res.partySize < min) return false;\n        if (max && res.partySize > max) return false;\n        return true;\n      });\n    }\n    \n    if (filters.source?.length) {\n      filteredReservations = filteredReservations.filter(res => \n        filters.source!.includes(res.source)\n      );\n    }\n  }\n  \n  return {\n    data: filteredReservations,\n    pagination: {\n      page: 1,\n      limit: 50,\n      total: filteredReservations.length,\n      totalPages: 1\n    }\n  };\n}\n\nexport async function getWaitlist(filters?: WaitlistFilters): Promise<WaitlistEntry[]> {\n  await new Promise(resolve => setTimeout(resolve, 200));\n  \n  let filteredWaitlist = [...mockWaitlist];\n  \n  if (filters) {\n    if (filters.status?.length) {\n      filteredWaitlist = filteredWaitlist.filter(entry => \n        filters.status!.includes(entry.status)\n      );\n    }\n    \n    if (filters.priority?.length) {\n      filteredWaitlist = filteredWaitlist.filter(entry => \n        filters.priority!.includes(entry.priority)\n      );\n    }\n    \n    if (filters.partySize) {\n      const { min, max } = filters.partySize;\n      filteredWaitlist = filteredWaitlist.filter(entry => {\n        if (min && entry.partySize < min) return false;\n        if (max && entry.partySize > max) return false;\n        return true;\n      });\n    }\n  }\n  \n  return filteredWaitlist;\n}\n\nexport async function getGuests(search?: string): Promise<Guest[]> {\n  await new Promise(resolve => setTimeout(resolve, 300));\n  \n  if (search) {\n    const searchLower = search.toLowerCase();\n    return mockGuests.filter(guest => \n      guest.firstName.toLowerCase().includes(searchLower) ||\n      guest.lastName.toLowerCase().includes(searchLower) ||\n      guest.phone.includes(search) ||\n      guest.email?.toLowerCase().includes(searchLower)\n    );\n  }\n  \n  return mockGuests;\n}\n\nexport async function getGuestById(id: string): Promise<Guest | null> {\n  await new Promise(resolve => setTimeout(resolve, 200));\n  return mockGuests.find(guest => guest.id === id) || null;\n}\n\nexport async function createReservation(data: CreateReservationData): Promise<ApiResponse<Reservation>> {\n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  // Simulate validation\n  if (data.partySize < 1 || data.partySize > 20) {\n    return {\n      success: false,\n      error: 'Party size must be between 1 and 20'\n    };\n  }\n  \n  const newReservation: Reservation = {\n    id: `res-${Date.now()}`,\n    guestId: data.guestId || `guest-${Date.now()}`,\n    partySize: data.partySize,\n    dateTime: data.dateTime,\n    duration: data.duration || 120,\n    status: 'confirmed',\n    specialRequests: data.specialRequests,\n    occasion: data.occasion,\n    notes: data.notes,\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString(),\n    source: data.source,\n    tags: data.tags\n  };\n  \n  return {\n    success: true,\n    data: newReservation,\n    message: 'Reservation created successfully'\n  };\n}\n\nexport async function updateReservation(id: string, data: UpdateReservationData): Promise<ApiResponse<Reservation>> {\n  await new Promise(resolve => setTimeout(resolve, 400));\n  \n  const reservation = mockReservations.find(r => r.id === id);\n  if (!reservation) {\n    return {\n      success: false,\n      error: 'Reservation not found'\n    };\n  }\n  \n  const updatedReservation: Reservation = {\n    ...reservation,\n    ...data,\n    updatedAt: new Date().toISOString()\n  };\n  \n  return {\n    success: true,\n    data: updatedReservation,\n    message: 'Reservation updated successfully'\n  };\n}\n\nexport async function cancelReservation(id: string): Promise<ApiResponse<void>> {\n  await new Promise(resolve => setTimeout(resolve, 300));\n  \n  const reservation = mockReservations.find(r => r.id === id);\n  if (!reservation) {\n    return {\n      success: false,\n      error: 'Reservation not found'\n    };\n  }\n  \n  return {\n    success: true,\n    message: 'Reservation cancelled successfully'\n  };\n}\n\nexport async function addToWaitlist(data: CreateWaitlistEntryData): Promise<ApiResponse<WaitlistEntry>> {\n  await new Promise(resolve => setTimeout(resolve, 300));\n  \n  const newWaitlistEntry: WaitlistEntry = {\n    id: `wait-${Date.now()}`,\n    guestId: data.guestId || `guest-${Date.now()}`,\n    partySize: data.partySize,\n    estimatedWaitTime: data.estimatedWaitTime,\n    priority: data.priority || 'normal',\n    addedAt: new Date().toISOString(),\n    phoneNumber: data.guest?.phone || '',\n    status: 'waiting',\n    specialRequests: data.specialRequests,\n    quotedWaitTime: data.quotedWaitTime\n  };\n  \n  return {\n    success: true,\n    data: newWaitlistEntry,\n    message: 'Added to waitlist successfully'\n  };\n}\n\nexport async function updateWaitlistEntry(id: string, status: WaitlistStatus): Promise<ApiResponse<WaitlistEntry>> {\n  await new Promise(resolve => setTimeout(resolve, 200));\n  \n  const entry = mockWaitlist.find(e => e.id === id);\n  if (!entry) {\n    return {\n      success: false,\n      error: 'Waitlist entry not found'\n    };\n  }\n  \n  const updatedEntry: WaitlistEntry = {\n    ...entry,\n    status,\n    ...(status === 'notified' && { notifiedAt: new Date().toISOString() }),\n    ...(status === 'seated' && { seatedAt: new Date().toISOString() })\n  };\n  \n  return {\n    success: true,\n    data: updatedEntry,\n    message: 'Waitlist entry updated successfully'\n  };\n}\n\nexport async function updateTableStatus(tableId: string, status: TableStatus): Promise<ApiResponse<Table>> {\n  await new Promise(resolve => setTimeout(resolve, 200));\n  \n  const table = mockTables.find(t => t.id === tableId);\n  if (!table) {\n    return {\n      success: false,\n      error: 'Table not found'\n    };\n  }\n  \n  const updatedTable: Table = {\n    ...table,\n    status,\n    ...(status === 'cleaning' && { lastCleanedAt: new Date().toISOString() })\n  };\n  \n  return {\n    success: true,\n    data: updatedTable,\n    message: 'Table status updated successfully'\n  };\n}\n\nexport async function getReservationStats(): Promise<ReservationStats> {\n  await new Promise(resolve => setTimeout(resolve, 400));\n  \n  return {\n    today: {\n      totalReservations: 45,\n      seated: 28,\n      pending: 12,\n      noShows: 3,\n      walkIns: 8,\n      averagePartySize: 3.2,\n      totalCovers: 144\n    },\n    current: {\n      occupiedTables: 12,\n      availableTables: 8,\n      waitlistSize: 6,\n      averageWaitTime: 22,\n      nextAvailableSlot: '2024-01-20T21:30:00Z'\n    },\n    forecast: {\n      remainingCapacity: 45,\n      expectedTurnover: 15,\n      projectedRevenue: 2800\n    }\n  };\n}\n\nexport async function getAvailability(date: string): Promise<AvailabilityWindow> {\n  await new Promise(resolve => setTimeout(resolve, 300));\n  \n  // Mock availability data\n  const slots = [];\n  for (let hour = 17; hour <= 22; hour++) {\n    for (let minute = 0; minute < 60; minute += 30) {\n      const time = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n      slots.push({\n        time,\n        capacity: 80,\n        booked: Math.floor(Math.random() * 60),\n        available: Math.floor(Math.random() * 20),\n        tables: mockTables.map(table => ({\n          tableId: table.id,\n          status: Math.random() > 0.7 ? 'reserved' : 'available' as 'available' | 'reserved' | 'blocked'\n        }))\n      });\n    }\n  }\n  \n  const totalBooked = slots.reduce((sum, slot) => sum + slot.booked, 0);\n  const totalCapacity = slots.length * 80;\n  \n  return {\n    date,\n    slots,\n    totalCapacity,\n    totalBooked,\n    isFullyBooked: totalBooked >= totalCapacity * 0.95\n  };\n}\n\nexport async function getTableTurnover(date: string, tableId?: string): Promise<TableTurnover[]> {\n  await new Promise(resolve => setTimeout(resolve, 400));\n  \n  const tables = tableId ? [tableId] : mockTables.map(t => t.id);\n  \n  return tables.map(id => ({\n    tableId: id,\n    date,\n    turns: [\n      {\n        reservationId: 'res-1',\n        startTime: '18:00',\n        endTime: '20:00',\n        duration: 120,\n        partySize: 4,\n        revenue: 180\n      },\n      {\n        reservationId: 'res-2',\n        startTime: '20:30',\n        endTime: '22:15',\n        duration: 105,\n        partySize: 2,\n        revenue: 95\n      }\n    ],\n    totalTurns: 2,\n    averageTurnTime: 112.5,\n    totalRevenue: 275,\n    efficiency: 85\n  }));\n}\n\n// Real-time data simulation\nlet subscribers: ((data: any) => void)[] = [];\n\nexport function subscribeToUpdates(callback: (data: any) => void) {\n  subscribers.push(callback);\n  \n  return () => {\n    subscribers = subscribers.filter(cb => cb !== callback);\n  };\n}\n\n// Simulate real-time updates\nsetInterval(() => {\n  if (subscribers.length > 0) {\n    const updateType = Math.random();\n    let update;\n    \n    if (updateType < 0.4) {\n      // Table status update\n      const table = mockTables[Math.floor(Math.random() * mockTables.length)];\n      const statuses: TableStatus[] = ['available', 'occupied', 'reserved', 'cleaning'];\n      update = {\n        type: 'table',\n        action: 'update',\n        data: {\n          ...table,\n          status: statuses[Math.floor(Math.random() * statuses.length)]\n        },\n        timestamp: new Date().toISOString()\n      };\n    } else if (updateType < 0.7) {\n      // Reservation update\n      const reservation = mockReservations[Math.floor(Math.random() * mockReservations.length)];\n      update = {\n        type: 'reservation',\n        action: 'update',\n        data: {\n          ...reservation,\n          status: 'seated' as ReservationStatus\n        },\n        timestamp: new Date().toISOString()\n      };\n    } else {\n      // Waitlist update\n      const waitlistEntry = mockWaitlist[Math.floor(Math.random() * mockWaitlist.length)];\n      update = {\n        type: 'waitlist',\n        action: 'update',\n        data: {\n          ...waitlistEntry,\n          estimatedWaitTime: Math.max(0, waitlistEntry.estimatedWaitTime - 5)\n        },\n        timestamp: new Date().toISOString()\n      };\n    }\n    \n    subscribers.forEach(callback => callback(update));\n  }\n}, 30000); // Update every 30 seconds","import { SMSNotification, WaitlistEntry, Reservation, Guest } from './types';\n\n// SMS Templates\nconst SMS_TEMPLATES = {\n  RESERVATION_CONFIRMATION: (guestName: string, date: string, time: string, partySize: number) =>\n    `Hi ${guestName}, your reservation for ${partySize} on ${date} at ${time} is confirmed. Reply CANCEL to cancel. - {Restaurant Name}`,\n  \n  RESERVATION_REMINDER: (guestName: string, time: string, partySize: number) =>\n    `Hi ${guestName}, reminder: your table for ${partySize} is reserved for ${time} today. See you soon! - {Restaurant Name}`,\n  \n  TABLE_READY: (guestName: string, estimatedWait?: number) =>\n    `Hi ${guestName}, your table is ready! Please come to the host stand within the next 10 minutes. - {Restaurant Name}`,\n  \n  WAITLIST_UPDATE: (guestName: string, position: number, estimatedWait: number) =>\n    `Hi ${guestName}, you're #${position} on our waitlist. Estimated wait time: ${estimatedWait} minutes. - {Restaurant Name}`,\n  \n  RESERVATION_CANCELLED: (guestName: string, date: string, time: string) =>\n    `Hi ${guestName}, your reservation for ${date} at ${time} has been cancelled. We hope to see you again soon! - {Restaurant Name}`,\n  \n  NO_SHOW_FOLLOW_UP: (guestName: string) =>\n    `Hi ${guestName}, we missed you today! If something came up, please let us know. We'd love to reschedule. - {Restaurant Name}`,\n  \n  WAITLIST_EXPIRED: (guestName: string) =>\n    `Hi ${guestName}, your waitlist spot has expired. Please visit the host stand if you're still interested in dining with us. - {Restaurant Name}`,\n  \n  SPECIAL_OCCASION: (guestName: string, occasion: string, time: string) =>\n    `Hi ${guestName}, we're excited to celebrate your ${occasion} with you today at ${time}! - {Restaurant Name}`,\n};\n\ninterface SMSConfig {\n  restaurantName: string;\n  fromNumber: string;\n  provider: 'twilio' | 'mock';\n  credentials?: {\n    accountSid?: string;\n    authToken?: string;\n  };\n  enableDeliveryReceipts: boolean;\n  enableOptOut: boolean;\n  maxRetries: number;\n}\n\n// Mock SMS service configuration\nconst defaultConfig: SMSConfig = {\n  restaurantName: 'Bella Vista Restaurant',\n  fromNumber: '+1234567890',\n  provider: 'mock',\n  enableDeliveryReceipts: true,\n  enableOptOut: true,\n  maxRetries: 3\n};\n\nclass SMSService {\n  private config: SMSConfig;\n  private notifications: SMSNotification[] = [];\n  \n  constructor(config: Partial<SMSConfig> = {}) {\n    this.config = { ...defaultConfig, ...config };\n  }\n  \n  private generateNotificationId(): string {\n    return `sms_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n  \n  private formatTemplate(template: string): string {\n    return template.replace('{Restaurant Name}', this.config.restaurantName);\n  }\n  \n  private async sendSMS(phoneNumber: string, message: string, type: SMSNotification['type'], relatedId?: string): Promise<SMSNotification> {\n    const notification: SMSNotification = {\n      id: this.generateNotificationId(),\n      phoneNumber,\n      message: this.formatTemplate(message),\n      type,\n      status: 'pending',\n      ...(relatedId && { reservationId: relatedId }),\n    };\n    \n    this.notifications.push(notification);\n    \n    try {\n      // Simulate sending SMS\n      await this.mockSendSMS(notification);\n      \n      notification.status = 'sent';\n      notification.sentAt = new Date().toISOString();\n      \n      // Simulate delivery receipt after a delay\n      setTimeout(() => {\n        if (this.config.enableDeliveryReceipts) {\n          notification.status = 'delivered';\n          notification.deliveredAt = new Date().toISOString();\n        }\n      }, Math.random() * 3000 + 1000); // 1-4 seconds\n      \n      return notification;\n      \n    } catch (error) {\n      notification.status = 'failed';\n      notification.errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      throw error;\n    }\n  }\n  \n  private async mockSendSMS(notification: SMSNotification): Promise<void> {\n    // Simulate API call delay\n    await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 500));\n    \n    // Simulate occasional failures (5% failure rate)\n    if (Math.random() < 0.05) {\n      throw new Error('SMS delivery failed');\n    }\n    \n    console.log(`[SMS Mock] Sending to ${notification.phoneNumber}: ${notification.message}`);\n  }\n  \n  // Public methods for different notification types\n  async sendReservationConfirmation(\n    reservation: Reservation, \n    guest: Guest\n  ): Promise<SMSNotification> {\n    const date = new Date(reservation.dateTime).toLocaleDateString();\n    const time = new Date(reservation.dateTime).toLocaleTimeString('en-US', {\n      hour: '2-digit',\n      minute: '2-digit',\n      hour12: true\n    });\n    \n    const message = SMS_TEMPLATES.RESERVATION_CONFIRMATION(\n      guest.firstName,\n      date,\n      time,\n      reservation.partySize\n    );\n    \n    return this.sendSMS(guest.phone, message, 'confirmation', reservation.id);\n  }\n  \n  async sendReservationReminder(\n    reservation: Reservation, \n    guest: Guest\n  ): Promise<SMSNotification> {\n    const time = new Date(reservation.dateTime).toLocaleTimeString('en-US', {\n      hour: '2-digit',\n      minute: '2-digit',\n      hour12: true\n    });\n    \n    const message = SMS_TEMPLATES.RESERVATION_REMINDER(\n      guest.firstName,\n      time,\n      reservation.partySize\n    );\n    \n    return this.sendSMS(guest.phone, message, 'reservation_reminder', reservation.id);\n  }\n  \n  async sendTableReadyNotification(\n    waitlistEntry: WaitlistEntry, \n    guest: Guest\n  ): Promise<SMSNotification> {\n    const message = SMS_TEMPLATES.TABLE_READY(guest.firstName);\n    \n    const notification = await this.sendSMS(guest.phone, message, 'table_ready');\n    notification.waitlistEntryId = waitlistEntry.id;\n    return notification;\n  }\n  \n  async sendWaitlistUpdate(\n    waitlistEntry: WaitlistEntry, \n    guest: Guest, \n    position: number\n  ): Promise<SMSNotification> {\n    const message = SMS_TEMPLATES.WAITLIST_UPDATE(\n      guest.firstName,\n      position,\n      waitlistEntry.estimatedWaitTime\n    );\n    \n    const notification = await this.sendSMS(guest.phone, message, 'waitlist_update');\n    notification.waitlistEntryId = waitlistEntry.id;\n    return notification;\n  }\n  \n  async sendReservationCancellation(\n    reservation: Reservation, \n    guest: Guest\n  ): Promise<SMSNotification> {\n    const date = new Date(reservation.dateTime).toLocaleDateString();\n    const time = new Date(reservation.dateTime).toLocaleTimeString('en-US', {\n      hour: '2-digit',\n      minute: '2-digit',\n      hour12: true\n    });\n    \n    const message = SMS_TEMPLATES.RESERVATION_CANCELLED(\n      guest.firstName,\n      date,\n      time\n    );\n    \n    return this.sendSMS(guest.phone, message, 'confirmation', reservation.id);\n  }\n  \n  async sendNoShowFollowUp(\n    reservation: Reservation, \n    guest: Guest\n  ): Promise<SMSNotification> {\n    const message = SMS_TEMPLATES.NO_SHOW_FOLLOW_UP(guest.firstName);\n    \n    return this.sendSMS(guest.phone, message, 'reservation_reminder', reservation.id);\n  }\n  \n  async sendSpecialOccasionMessage(\n    reservation: Reservation, \n    guest: Guest\n  ): Promise<SMSNotification> {\n    if (!reservation.occasion) {\n      throw new Error('No special occasion specified');\n    }\n    \n    const time = new Date(reservation.dateTime).toLocaleTimeString('en-US', {\n      hour: '2-digit',\n      minute: '2-digit',\n      hour12: true\n    });\n    \n    const message = SMS_TEMPLATES.SPECIAL_OCCASION(\n      guest.firstName,\n      reservation.occasion,\n      time\n    );\n    \n    return this.sendSMS(guest.phone, message, 'reservation_reminder', reservation.id);\n  }\n  \n  async sendCustomMessage(\n    phoneNumber: string, \n    message: string, \n    relatedId?: string\n  ): Promise<SMSNotification> {\n    return this.sendSMS(phoneNumber, message, 'confirmation', relatedId);\n  }\n  \n  // Bulk operations\n  async sendBulkReminders(\n    reservations: { reservation: Reservation; guest: Guest }[]\n  ): Promise<SMSNotification[]> {\n    const notifications: SMSNotification[] = [];\n    const batchSize = 10; // Send in batches to avoid rate limiting\n    \n    for (let i = 0; i < reservations.length; i += batchSize) {\n      const batch = reservations.slice(i, i + batchSize);\n      const batchPromises = batch.map(({ reservation, guest }) =>\n        this.sendReservationReminder(reservation, guest)\n      );\n      \n      try {\n        const batchResults = await Promise.allSettled(batchPromises);\n        batchResults.forEach((result, index) => {\n          if (result.status === 'fulfilled') {\n            notifications.push(result.value);\n          } else {\n            console.error(`Failed to send reminder to ${batch[index].guest.phone}:`, result.reason);\n          }\n        });\n        \n        // Add delay between batches\n        if (i + batchSize < reservations.length) {\n          await new Promise(resolve => setTimeout(resolve, 1000));\n        }\n      } catch (error) {\n        console.error('Batch SMS sending error:', error);\n      }\n    }\n    \n    return notifications;\n  }\n  \n  // Notification management\n  getNotifications(filters?: {\n    phoneNumber?: string;\n    type?: SMSNotification['type'];\n    status?: SMSNotification['status'];\n    dateRange?: { start: string; end: string };\n  }): SMSNotification[] {\n    let filtered = [...this.notifications];\n    \n    if (filters) {\n      if (filters.phoneNumber) {\n        filtered = filtered.filter(n => n.phoneNumber.includes(filters.phoneNumber!));\n      }\n      \n      if (filters.type) {\n        filtered = filtered.filter(n => n.type === filters.type);\n      }\n      \n      if (filters.status) {\n        filtered = filtered.filter(n => n.status === filters.status);\n      }\n      \n      if (filters.dateRange) {\n        const start = new Date(filters.dateRange.start);\n        const end = new Date(filters.dateRange.end);\n        filtered = filtered.filter(n => {\n          const notificationDate = new Date(n.sentAt || Date.now());\n          return notificationDate >= start && notificationDate <= end;\n        });\n      }\n    }\n    \n    return filtered.sort((a, b) => \n      new Date(b.sentAt || b.id).getTime() - new Date(a.sentAt || a.id).getTime()\n    );\n  }\n  \n  getNotificationById(id: string): SMSNotification | undefined {\n    return this.notifications.find(n => n.id === id);\n  }\n  \n  async retryFailedNotification(id: string): Promise<SMSNotification> {\n    const notification = this.getNotificationById(id);\n    if (!notification) {\n      throw new Error('Notification not found');\n    }\n    \n    if (notification.status !== 'failed') {\n      throw new Error('Can only retry failed notifications');\n    }\n    \n    // Create new notification for retry\n    return this.sendSMS(\n      notification.phoneNumber,\n      notification.message,\n      notification.type,\n      notification.reservationId || notification.waitlistEntryId\n    );\n  }\n  \n  // Analytics\n  getNotificationStats(dateRange?: { start: string; end: string }) {\n    const notifications = this.getNotifications(dateRange ? { dateRange } : undefined);\n    \n    return {\n      total: notifications.length,\n      sent: notifications.filter(n => n.status === 'sent' || n.status === 'delivered').length,\n      delivered: notifications.filter(n => n.status === 'delivered').length,\n      failed: notifications.filter(n => n.status === 'failed').length,\n      pending: notifications.filter(n => n.status === 'pending').length,\n      deliveryRate: notifications.length > 0 \n        ? (notifications.filter(n => n.status === 'delivered').length / notifications.length) * 100 \n        : 0,\n      byType: {\n        confirmation: notifications.filter(n => n.type === 'confirmation').length,\n        reminder: notifications.filter(n => n.type === 'reservation_reminder').length,\n        tableReady: notifications.filter(n => n.type === 'table_ready').length,\n        waitlistUpdate: notifications.filter(n => n.type === 'waitlist_update').length,\n      }\n    };\n  }\n  \n  // Configuration\n  updateConfig(newConfig: Partial<SMSConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n  }\n  \n  getConfig(): SMSConfig {\n    return { ...this.config };\n  }\n}\n\n// Automated SMS workflows\nexport class AutomatedSMSWorkflows {\n  private smsService: SMSService;\n  \n  constructor(smsService: SMSService) {\n    this.smsService = smsService;\n  }\n  \n  // Send reminder 24 hours before reservation\n  async scheduleReservationReminders(reservations: { reservation: Reservation; guest: Guest }[]): Promise<void> {\n    const tomorrow = new Date();\n    tomorrow.setDate(tomorrow.getDate() + 1);\n    tomorrow.setHours(0, 0, 0, 0);\n    \n    const tomorrowEnd = new Date(tomorrow);\n    tomorrowEnd.setHours(23, 59, 59, 999);\n    \n    const tomorrowReservations = reservations.filter(({ reservation }) => {\n      const resDate = new Date(reservation.dateTime);\n      return resDate >= tomorrow && resDate <= tomorrowEnd && reservation.status === 'confirmed';\n    });\n    \n    if (tomorrowReservations.length > 0) {\n      console.log(`Sending ${tomorrowReservations.length} reservation reminders`);\n      await this.smsService.sendBulkReminders(tomorrowReservations);\n    }\n  }\n  \n  // Send special occasion messages\n  async sendSpecialOccasionReminders(reservations: { reservation: Reservation; guest: Guest }[]): Promise<void> {\n    const specialOccasionReservations = reservations.filter(({ reservation }) => \n      reservation.occasion && reservation.status === 'confirmed'\n    );\n    \n    for (const { reservation, guest } of specialOccasionReservations) {\n      try {\n        await this.smsService.sendSpecialOccasionMessage(reservation, guest);\n      } catch (error) {\n        console.error(`Failed to send special occasion message for reservation ${reservation.id}:`, error);\n      }\n    }\n  }\n  \n  // Update waitlist positions\n  async updateWaitlistPositions(waitlistEntries: { entry: WaitlistEntry; guest: Guest }[]): Promise<void> {\n    const waitingEntries = waitlistEntries.filter(({ entry }) => entry.status === 'waiting');\n    \n    for (let i = 0; i < waitingEntries.length; i++) {\n      const { entry, guest } = waitingEntries[i];\n      const position = i + 1;\n      \n      // Only send updates if position or wait time changed significantly\n      if (Math.abs(entry.estimatedWaitTime - (position * 15)) > 10) {\n        try {\n          await this.smsService.sendWaitlistUpdate(entry, guest, position);\n        } catch (error) {\n          console.error(`Failed to send waitlist update for entry ${entry.id}:`, error);\n        }\n      }\n    }\n  }\n  \n  // Follow up on no-shows\n  async followUpNoShows(noShowReservations: { reservation: Reservation; guest: Guest }[]): Promise<void> {\n    for (const { reservation, guest } of noShowReservations) {\n      try {\n        await this.smsService.sendNoShowFollowUp(reservation, guest);\n      } catch (error) {\n        console.error(`Failed to send no-show follow-up for reservation ${reservation.id}:`, error);\n      }\n    }\n  }\n}\n\n// Export singleton instance\nexport const smsService = new SMSService();\nexport const automatedWorkflows = new AutomatedSMSWorkflows(smsService);\n\n// Export types and utilities\nexport { SMSService, SMS_TEMPLATES };\nexport type { SMSConfig };","import { \n  Table, \n  Reservation, \n  Guest, \n  WaitlistEntry, \n  TableStatus,\n  ReservationStatus,\n  WaitlistStatus,\n  TableTurnover,\n  AvailabilityWindow,\n  FloorPlanElement,\n  VIPStatus\n} from './types';\n\n// Date and Time Utilities\nexport function formatTime(dateString: string): string {\n  return new Date(dateString).toLocaleTimeString('en-US', {\n    hour: '2-digit',\n    minute: '2-digit',\n    hour12: true\n  });\n}\n\nexport function formatDate(dateString: string): string {\n  return new Date(dateString).toLocaleDateString('en-US', {\n    weekday: 'short',\n    year: 'numeric',\n    month: 'short',\n    day: 'numeric'\n  });\n}\n\nexport function formatDateTime(dateString: string): string {\n  const date = new Date(dateString);\n  return `${formatDate(dateString)} at ${formatTime(dateString)}`;\n}\n\nexport function isToday(dateString: string): boolean {\n  const today = new Date();\n  const date = new Date(dateString);\n  return today.toDateString() === date.toDateString();\n}\n\nexport function isTomorrow(dateString: string): boolean {\n  const tomorrow = new Date();\n  tomorrow.setDate(tomorrow.getDate() + 1);\n  const date = new Date(dateString);\n  return tomorrow.toDateString() === date.toDateString();\n}\n\nexport function getTimeSlots(startHour: number = 17, endHour: number = 23, interval: number = 30): string[] {\n  const slots = [];\n  for (let hour = startHour; hour <= endHour; hour++) {\n    for (let minute = 0; minute < 60; minute += interval) {\n      if (hour === endHour && minute > 0) break;\n      const timeString = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n      slots.push(timeString);\n    }\n  }\n  return slots;\n}\n\nexport function addMinutes(dateString: string, minutes: number): string {\n  const date = new Date(dateString);\n  date.setMinutes(date.getMinutes() + minutes);\n  return date.toISOString();\n}\n\nexport function getDurationInMinutes(startTime: string, endTime: string): number {\n  const start = new Date(startTime);\n  const end = new Date(endTime);\n  return Math.floor((end.getTime() - start.getTime()) / (1000 * 60));\n}\n\nexport function isTimeSlotAvailable(\n  targetTime: string,\n  duration: number,\n  existingReservations: Reservation[],\n  tableId?: string\n): boolean {\n  const targetStart = new Date(targetTime);\n  const targetEnd = new Date(targetStart.getTime() + duration * 60000);\n  \n  return !existingReservations.some(reservation => {\n    if (tableId && reservation.tableId !== tableId) return false;\n    if (reservation.status === 'cancelled' || reservation.status === 'no-show') return false;\n    \n    const resStart = new Date(reservation.dateTime);\n    const resEnd = new Date(resStart.getTime() + reservation.duration * 60000);\n    \n    return (targetStart < resEnd && targetEnd > resStart);\n  });\n}\n\n// Table Management Utilities\nexport function getTableStatusColor(status: TableStatus): string {\n  switch (status) {\n    case 'available':\n      return '#10B981'; // green\n    case 'occupied':\n      return '#EF4444'; // red\n    case 'reserved':\n      return '#F59E0B'; // amber\n    case 'cleaning':\n      return '#6B7280'; // gray\n    case 'maintenance':\n      return '#8B5CF6'; // purple\n    case 'combined':\n      return '#3B82F6'; // blue\n    default:\n      return '#6B7280';\n  }\n}\n\nexport function getTableStatusLabel(status: TableStatus): string {\n  switch (status) {\n    case 'available':\n      return 'Available';\n    case 'occupied':\n      return 'Occupied';\n    case 'reserved':\n      return 'Reserved';\n    case 'cleaning':\n      return 'Cleaning';\n    case 'maintenance':\n      return 'Maintenance';\n    case 'combined':\n      return 'Combined';\n    default:\n      return 'Unknown';\n  }\n}\n\nexport function canCombineTables(tables: Table[]): boolean {\n  if (tables.length < 2) return false;\n  \n  return tables.every(table => \n    table.isCombinable && \n    table.status === 'available' &&\n    table.diningAreaId === tables[0].diningAreaId\n  );\n}\n\nexport function calculateCombinedCapacity(tables: Table[]): number {\n  return tables.reduce((total, table) => total + table.capacity, 0);\n}\n\nexport function findOptimalTable(\n  tables: Table[],\n  partySize: number,\n  preferredArea?: string\n): Table | null {\n  let availableTables = tables.filter(table => \n    table.status === 'available' && \n    table.capacity >= partySize &&\n    (!preferredArea || table.diningAreaId === preferredArea)\n  );\n  \n  if (availableTables.length === 0) {\n    // Try to find combinable tables\n    const combinableTables = tables.filter(table => \n      table.status === 'available' && \n      table.isCombinable &&\n      (!preferredArea || table.diningAreaId === preferredArea)\n    );\n    \n    // Simple combination logic - find two tables that together meet capacity\n    for (let i = 0; i < combinableTables.length; i++) {\n      for (let j = i + 1; j < combinableTables.length; j++) {\n        const combined = [combinableTables[i], combinableTables[j]];\n        if (calculateCombinedCapacity(combined) >= partySize) {\n          return combinableTables[i]; // Return first table as primary\n        }\n      }\n    }\n    \n    return null;\n  }\n  \n  // Sort by capacity (prefer table closest to party size)\n  availableTables.sort((a, b) => {\n    const diffA = Math.abs(a.capacity - partySize);\n    const diffB = Math.abs(b.capacity - partySize);\n    return diffA - diffB;\n  });\n  \n  return availableTables[0];\n}\n\nexport function estimateTableAvailability(\n  table: Table,\n  currentReservations: Reservation[],\n  averageTurnoverTime?: number\n): string | null {\n  const currentTime = new Date();\n  const turnover = averageTurnoverTime || table.estimatedTurnoverTime || 120;\n  \n  if (table.status === 'available') return 'Now';\n  if (table.status === 'maintenance' || table.status === 'cleaning') return null;\n  \n  // Find current or next reservation\n  const activeReservation = currentReservations.find(res => \n    res.tableId === table.id && \n    res.status === 'seated' &&\n    new Date(res.seatedAt || res.dateTime) <= currentTime\n  );\n  \n  if (activeReservation) {\n    const seatedTime = new Date(activeReservation.seatedAt || activeReservation.dateTime);\n    const estimatedEnd = new Date(seatedTime.getTime() + turnover * 60000);\n    \n    if (estimatedEnd > currentTime) {\n      return formatTime(estimatedEnd.toISOString());\n    }\n  }\n  \n  return 'Now';\n}\n\n// Reservation Utilities\nexport function getReservationStatusColor(status: ReservationStatus): string {\n  switch (status) {\n    case 'confirmed':\n      return '#10B981'; // green\n    case 'pending':\n      return '#F59E0B'; // amber\n    case 'seated':\n      return '#3B82F6'; // blue\n    case 'completed':\n      return '#6B7280'; // gray\n    case 'cancelled':\n      return '#EF4444'; // red\n    case 'no-show':\n      return '#DC2626'; // dark red\n    default:\n      return '#6B7280';\n  }\n}\n\nexport function getReservationStatusLabel(status: ReservationStatus): string {\n  switch (status) {\n    case 'confirmed':\n      return 'Confirmed';\n    case 'pending':\n      return 'Pending';\n    case 'seated':\n      return 'Seated';\n    case 'completed':\n      return 'Completed';\n    case 'cancelled':\n      return 'Cancelled';\n    case 'no-show':\n      return 'No Show';\n    default:\n      return 'Unknown';\n  }\n}\n\nexport function isReservationLate(reservation: Reservation): boolean {\n  if (reservation.status !== 'confirmed' && reservation.status !== 'pending') {\n    return false;\n  }\n  \n  const now = new Date();\n  const reservationTime = new Date(reservation.dateTime);\n  const gracePeriod = 15 * 60 * 1000; // 15 minutes in milliseconds\n  \n  return now.getTime() > (reservationTime.getTime() + gracePeriod);\n}\n\nexport function getReservationTimeStatus(reservation: Reservation): 'early' | 'on-time' | 'late' | 'very-late' {\n  const now = new Date();\n  const reservationTime = new Date(reservation.dateTime);\n  const diffMinutes = (now.getTime() - reservationTime.getTime()) / (1000 * 60);\n  \n  if (diffMinutes < -30) return 'early';\n  if (diffMinutes >= -30 && diffMinutes <= 15) return 'on-time';\n  if (diffMinutes > 15 && diffMinutes <= 45) return 'late';\n  return 'very-late';\n}\n\nexport function calculateExpectedRevenue(reservation: Reservation, averageSpendPerPerson: number = 45): number {\n  if (reservation.estimatedSpend) return reservation.estimatedSpend;\n  return reservation.partySize * averageSpendPerPerson;\n}\n\n// Waitlist Utilities\nexport function getWaitlistStatusColor(status: WaitlistStatus): string {\n  switch (status) {\n    case 'waiting':\n      return '#F59E0B'; // amber\n    case 'notified':\n      return '#3B82F6'; // blue\n    case 'seated':\n      return '#10B981'; // green\n    case 'cancelled':\n      return '#EF4444'; // red\n    case 'no-show':\n      return '#DC2626'; // dark red\n    default:\n      return '#6B7280';\n  }\n}\n\nexport function getWaitlistPriorityColor(priority: string): string {\n  switch (priority) {\n    case 'vip':\n      return '#DC2626'; // red\n    case 'high':\n      return '#F59E0B'; // amber\n    case 'normal':\n      return '#10B981'; // green\n    case 'low':\n      return '#6B7280'; // gray\n    default:\n      return '#6B7280';\n  }\n}\n\nexport function updateWaitTimes(waitlist: WaitlistEntry[], averageTurnoverTime: number = 90): WaitlistEntry[] {\n  return waitlist\n    .filter(entry => entry.status === 'waiting')\n    .map((entry, index) => {\n      const baseWaitTime = (index + 1) * (averageTurnoverTime / 2);\n      const priorityMultiplier = entry.priority === 'vip' ? 0.5 : \n                                 entry.priority === 'high' ? 0.75 : 1;\n      \n      return {\n        ...entry,\n        estimatedWaitTime: Math.max(5, Math.round(baseWaitTime * priorityMultiplier))\n      };\n    });\n}\n\nexport function canSeatWaitlistEntry(entry: WaitlistEntry, availableTables: Table[]): boolean {\n  return availableTables.some(table => \n    table.status === 'available' && \n    table.capacity >= entry.partySize\n  );\n}\n\n// Guest Utilities\nexport function getGuestVIPStatusColor(status: VIPStatus): string {\n  switch (status) {\n    case 'celebrity':\n      return '#DC2626'; // red\n    case 'vip':\n      return '#F59E0B'; // amber\n    case 'frequent':\n      return '#3B82F6'; // blue\n    case 'regular':\n      return '#6B7280'; // gray\n    default:\n      return '#6B7280';\n  }\n}\n\nexport function getGuestVIPStatusLabel(status: VIPStatus): string {\n  switch (status) {\n    case 'celebrity':\n      return 'Celebrity';\n    case 'vip':\n      return 'VIP';\n    case 'frequent':\n      return 'Frequent Guest';\n    case 'regular':\n      return 'Regular';\n    default:\n      return 'Guest';\n  }\n}\n\nexport function calculateGuestLTV(guest: Guest): number {\n  if (guest.totalVisits === 0) return 0;\n  \n  const monthsSinceFirstVisit = guest.visitHistory.length > 0 \n    ? getDurationInMinutes(guest.createdAt, new Date().toISOString()) / (60 * 24 * 30)\n    : 1;\n  \n  const visitsPerMonth = guest.totalVisits / Math.max(monthsSinceFirstVisit, 1);\n  const projectedAnnualVisits = visitsPerMonth * 12;\n  \n  return projectedAnnualVisits * guest.averageSpend * 3; // 3-year projection\n}\n\nexport function getGuestTags(guest: Guest): string[] {\n  const tags = [];\n  \n  if (guest.vipStatus !== 'regular') {\n    tags.push(getGuestVIPStatusLabel(guest.vipStatus));\n  }\n  \n  if (guest.totalVisits > 50) tags.push('Loyal Customer');\n  if (guest.averageSpend > 100) tags.push('High Spender');\n  if (guest.preferences.dietaryRestrictions?.length) tags.push('Dietary Restrictions');\n  if (guest.preferences.allergies?.length) tags.push('Allergies');\n  if (guest.dateOfBirth) tags.push('Birthday on File');\n  if (guest.anniversary) tags.push('Anniversary on File');\n  \n  const daysSinceLastVisit = guest.lastVisit \n    ? getDurationInMinutes(guest.lastVisit, new Date().toISOString()) / (60 * 24)\n    : Infinity;\n  \n  if (daysSinceLastVisit > 90) tags.push('Needs Follow-up');\n  if (daysSinceLastVisit <= 7) tags.push('Recent Visitor');\n  \n  return tags;\n}\n\n// Floor Plan Utilities\nexport function isPointInTable(x: number, y: number, table: Table): boolean {\n  return x >= table.x && \n         x <= table.x + table.width && \n         y >= table.y && \n         y <= table.y + table.height;\n}\n\nexport function getTableCenter(table: Table): { x: number; y: number } {\n  return {\n    x: table.x + table.width / 2,\n    y: table.y + table.height / 2\n  };\n}\n\nexport function calculateDistance(point1: { x: number; y: number }, point2: { x: number; y: number }): number {\n  return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));\n}\n\nexport function findNearbyTables(table: Table, allTables: Table[], maxDistance: number = 150): Table[] {\n  const tableCenter = getTableCenter(table);\n  \n  return allTables.filter(otherTable => {\n    if (otherTable.id === table.id) return false;\n    \n    const otherCenter = getTableCenter(otherTable);\n    const distance = calculateDistance(tableCenter, otherCenter);\n    \n    return distance <= maxDistance && otherTable.diningAreaId === table.diningAreaId;\n  });\n}\n\nexport function validateTablePosition(table: Table, existingTables: Table[], floorPlan: { width: number; height: number }): string[] {\n  const errors = [];\n  \n  // Check boundaries\n  if (table.x < 0 || table.y < 0) {\n    errors.push('Table cannot be positioned outside floor plan boundaries');\n  }\n  \n  if (table.x + table.width > floorPlan.width || table.y + table.height > floorPlan.height) {\n    errors.push('Table extends beyond floor plan boundaries');\n  }\n  \n  // Check overlaps\n  const overlapping = existingTables.find(existingTable => {\n    if (existingTable.id === table.id) return false;\n    \n    return !(table.x + table.width <= existingTable.x ||\n             existingTable.x + existingTable.width <= table.x ||\n             table.y + table.height <= existingTable.y ||\n             existingTable.y + existingTable.height <= table.y);\n  });\n  \n  if (overlapping) {\n    errors.push(`Table overlaps with table ${overlapping.number}`);\n  }\n  \n  return errors;\n}\n\n// Analytics Utilities\nexport function calculateTableUtilization(turnover: TableTurnover): number {\n  const totalPossibleTurns = 8; // Assuming 8 possible turns per day\n  return (turnover.totalTurns / totalPossibleTurns) * 100;\n}\n\nexport function calculateAverageWaitTime(waitlist: WaitlistEntry[]): number {\n  const seatedEntries = waitlist.filter(entry => entry.status === 'seated' && entry.seatedAt);\n  \n  if (seatedEntries.length === 0) return 0;\n  \n  const totalWaitTime = seatedEntries.reduce((sum, entry) => {\n    const waitTime = getDurationInMinutes(entry.addedAt, entry.seatedAt!);\n    return sum + waitTime;\n  }, 0);\n  \n  return totalWaitTime / seatedEntries.length;\n}\n\nexport function predictPeakTimes(reservations: Reservation[]): { time: string; count: number }[] {\n  const timeCounts: { [key: string]: number } = {};\n  \n  reservations.forEach(reservation => {\n    const hour = new Date(reservation.dateTime).getHours();\n    const timeSlot = `${hour}:00`;\n    timeCounts[timeSlot] = (timeCounts[timeSlot] || 0) + 1;\n  });\n  \n  return Object.entries(timeCounts)\n    .map(([time, count]) => ({ time, count }))\n    .sort((a, b) => b.count - a.count);\n}\n\n// Validation Utilities\nexport function validateReservationData(data: any): string[] {\n  const errors = [];\n  \n  if (!data.partySize || data.partySize < 1 || data.partySize > 20) {\n    errors.push('Party size must be between 1 and 20');\n  }\n  \n  if (!data.dateTime) {\n    errors.push('Date and time is required');\n  } else {\n    const reservationDate = new Date(data.dateTime);\n    const now = new Date();\n    \n    if (reservationDate < now) {\n      errors.push('Reservation time cannot be in the past');\n    }\n    \n    const maxAdvanceBooking = new Date();\n    maxAdvanceBooking.setDate(maxAdvanceBooking.getDate() + 60);\n    \n    if (reservationDate > maxAdvanceBooking) {\n      errors.push('Reservations cannot be made more than 60 days in advance');\n    }\n  }\n  \n  if (data.guest) {\n    if (!data.guest.firstName || data.guest.firstName.trim().length < 2) {\n      errors.push('First name must be at least 2 characters');\n    }\n    \n    if (!data.guest.lastName || data.guest.lastName.trim().length < 2) {\n      errors.push('Last name must be at least 2 characters');\n    }\n    \n    if (!data.guest.phone || !/^\\+?[\\d\\s\\-\\(\\)]+$/.test(data.guest.phone)) {\n      errors.push('Valid phone number is required');\n    }\n    \n    if (data.guest.email && !/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(data.guest.email)) {\n      errors.push('Valid email address is required');\n    }\n  }\n  \n  return errors;\n}\n\nexport function validateGuestData(data: any): string[] {\n  const errors = [];\n  \n  if (!data.firstName || data.firstName.trim().length < 2) {\n    errors.push('First name must be at least 2 characters');\n  }\n  \n  if (!data.lastName || data.lastName.trim().length < 2) {\n    errors.push('Last name must be at least 2 characters');\n  }\n  \n  if (!data.phone || !/^\\+?[\\d\\s\\-\\(\\)]+$/.test(data.phone)) {\n    errors.push('Valid phone number is required');\n  }\n  \n  if (data.email && !/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(data.email)) {\n    errors.push('Valid email address is required');\n  }\n  \n  if (data.dateOfBirth) {\n    const birthDate = new Date(data.dateOfBirth);\n    const now = new Date();\n    const age = now.getFullYear() - birthDate.getFullYear();\n    \n    if (age < 0 || age > 120) {\n      errors.push('Invalid date of birth');\n    }\n  }\n  \n  return errors;\n}\n\n// Search and Filter Utilities\nexport function searchGuests(guests: Guest[], query: string): Guest[] {\n  const searchTerm = query.toLowerCase().trim();\n  \n  if (!searchTerm) return guests;\n  \n  return guests.filter(guest => \n    guest.firstName.toLowerCase().includes(searchTerm) ||\n    guest.lastName.toLowerCase().includes(searchTerm) ||\n    guest.phone.includes(searchTerm) ||\n    guest.email?.toLowerCase().includes(searchTerm) ||\n    `${guest.firstName} ${guest.lastName}`.toLowerCase().includes(searchTerm)\n  );\n}\n\nexport function sortReservations(reservations: Reservation[], sortBy: 'time' | 'name' | 'party' | 'status', order: 'asc' | 'desc' = 'asc'): Reservation[] {\n  return [...reservations].sort((a, b) => {\n    let comparison = 0;\n    \n    switch (sortBy) {\n      case 'time':\n        comparison = new Date(a.dateTime).getTime() - new Date(b.dateTime).getTime();\n        break;\n      case 'party':\n        comparison = a.partySize - b.partySize;\n        break;\n      case 'status':\n        comparison = a.status.localeCompare(b.status);\n        break;\n      default:\n        comparison = 0;\n    }\n    \n    return order === 'desc' ? -comparison : comparison;\n  });\n}"],"names":[],"mappings":"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"}