{"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/instrumentation/utils.ts","turbopack:///[project]/node_modules/next/dist/esm/server/web/spec-extension/adapters/headers.js","turbopack:///[project]/node_modules/next/dist/esm/server/base-http/index.js","turbopack:///[project]/node_modules/next/dist/esm/server/api-utils/index.js","turbopack:///[project]/node_modules/next/dist/esm/server/base-http/node.js","turbopack:///[project]/node_modules/next/dist/esm/server/api-utils/get-cookie-parser.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/router/utils/app-paths.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/page-path/ensure-leading-slash.js","turbopack:///[project]/node_modules/next/dist/src/server/lib/cache-control.ts","turbopack:///[project]/components/menu/menu-management-client.tsx/__nextjs-internal-proxy.mjs","turbopack:///[project]/app/menu/page.tsx","turbopack:///[project]/lib/menu/data.ts"],"sourcesContent":["export function getRevalidateReason(params: {\n  isOnDemandRevalidate?: boolean\n  isRevalidate?: boolean\n}): 'on-demand' | 'stale' | undefined {\n  if (params.isOnDemandRevalidate) {\n    return 'on-demand'\n  }\n  if (params.isRevalidate) {\n    return 'stale'\n  }\n  return undefined\n}\n","import { ReflectAdapter } from './reflect';\n/**\n * @internal\n */ export class ReadonlyHeadersError extends Error {\n    constructor(){\n        super('Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers');\n    }\n    static callable() {\n        throw new ReadonlyHeadersError();\n    }\n}\nexport class HeadersAdapter extends Headers {\n    constructor(headers){\n        // We've already overridden the methods that would be called, so we're just\n        // calling the super constructor to ensure that the instanceof check works.\n        super();\n        this.headers = new Proxy(headers, {\n            get (target, prop, receiver) {\n                // Because this is just an object, we expect that all \"get\" operations\n                // are for properties. If it's a \"get\" for a symbol, we'll just return\n                // the symbol.\n                if (typeof prop === 'symbol') {\n                    return ReflectAdapter.get(target, prop, receiver);\n                }\n                const lowercased = prop.toLowerCase();\n                // Let's find the original casing of the key. This assumes that there is\n                // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n                // headers object.\n                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);\n                // If the original casing doesn't exist, return undefined.\n                if (typeof original === 'undefined') return;\n                // If the original casing exists, return the value.\n                return ReflectAdapter.get(target, original, receiver);\n            },\n            set (target, prop, value, receiver) {\n                if (typeof prop === 'symbol') {\n                    return ReflectAdapter.set(target, prop, value, receiver);\n                }\n                const lowercased = prop.toLowerCase();\n                // Let's find the original casing of the key. This assumes that there is\n                // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n                // headers object.\n                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);\n                // If the original casing doesn't exist, use the prop as the key.\n                return ReflectAdapter.set(target, original ?? prop, value, receiver);\n            },\n            has (target, prop) {\n                if (typeof prop === 'symbol') return ReflectAdapter.has(target, prop);\n                const lowercased = prop.toLowerCase();\n                // Let's find the original casing of the key. This assumes that there is\n                // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n                // headers object.\n                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);\n                // If the original casing doesn't exist, return false.\n                if (typeof original === 'undefined') return false;\n                // If the original casing exists, return true.\n                return ReflectAdapter.has(target, original);\n            },\n            deleteProperty (target, prop) {\n                if (typeof prop === 'symbol') return ReflectAdapter.deleteProperty(target, prop);\n                const lowercased = prop.toLowerCase();\n                // Let's find the original casing of the key. This assumes that there is\n                // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n                // headers object.\n                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);\n                // If the original casing doesn't exist, return true.\n                if (typeof original === 'undefined') return true;\n                // If the original casing exists, delete the property.\n                return ReflectAdapter.deleteProperty(target, original);\n            }\n        });\n    }\n    /**\n   * Seals a Headers instance to prevent modification by throwing an error when\n   * any mutating method is called.\n   */ static seal(headers) {\n        return new Proxy(headers, {\n            get (target, prop, receiver) {\n                switch(prop){\n                    case 'append':\n                    case 'delete':\n                    case 'set':\n                        return ReadonlyHeadersError.callable;\n                    default:\n                        return ReflectAdapter.get(target, prop, receiver);\n                }\n            }\n        });\n    }\n    /**\n   * Merges a header value into a string. This stores multiple values as an\n   * array, so we need to merge them into a string.\n   *\n   * @param value a header value\n   * @returns a merged header value (a string)\n   */ merge(value) {\n        if (Array.isArray(value)) return value.join(', ');\n        return value;\n    }\n    /**\n   * Creates a Headers instance from a plain object or a Headers instance.\n   *\n   * @param headers a plain object or a Headers instance\n   * @returns a headers instance\n   */ static from(headers) {\n        if (headers instanceof Headers) return headers;\n        return new HeadersAdapter(headers);\n    }\n    append(name, value) {\n        const existing = this.headers[name];\n        if (typeof existing === 'string') {\n            this.headers[name] = [\n                existing,\n                value\n            ];\n        } else if (Array.isArray(existing)) {\n            existing.push(value);\n        } else {\n            this.headers[name] = value;\n        }\n    }\n    delete(name) {\n        delete this.headers[name];\n    }\n    get(name) {\n        const value = this.headers[name];\n        if (typeof value !== 'undefined') return this.merge(value);\n        return null;\n    }\n    has(name) {\n        return typeof this.headers[name] !== 'undefined';\n    }\n    set(name, value) {\n        this.headers[name] = value;\n    }\n    forEach(callbackfn, thisArg) {\n        for (const [name, value] of this.entries()){\n            callbackfn.call(thisArg, value, name, this);\n        }\n    }\n    *entries() {\n        for (const key of Object.keys(this.headers)){\n            const name = key.toLowerCase();\n            // We assert here that this is a string because we got it from the\n            // Object.keys() call above.\n            const value = this.get(name);\n            yield [\n                name,\n                value\n            ];\n        }\n    }\n    *keys() {\n        for (const key of Object.keys(this.headers)){\n            const name = key.toLowerCase();\n            yield name;\n        }\n    }\n    *values() {\n        for (const key of Object.keys(this.headers)){\n            // We assert here that this is a string because we got it from the\n            // Object.keys() call above.\n            const value = this.get(key);\n            yield value;\n        }\n    }\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n}\n\n//# sourceMappingURL=headers.js.map","import { RedirectStatusCode } from '../../client/components/redirect-status-code';\nimport { getCookieParser } from '../api-utils/get-cookie-parser';\nexport class BaseNextRequest {\n    constructor(method, url, body){\n        this.method = method;\n        this.url = url;\n        this.body = body;\n    }\n    // Utils implemented using the abstract methods above\n    get cookies() {\n        if (this._cookies) return this._cookies;\n        return this._cookies = getCookieParser(this.headers)();\n    }\n}\nexport class BaseNextResponse {\n    constructor(destination){\n        this.destination = destination;\n    }\n    // Utils implemented using the abstract methods above\n    redirect(destination, statusCode) {\n        this.setHeader('Location', destination);\n        this.statusCode = statusCode;\n        // Since IE11 doesn't support the 308 header add backwards\n        // compatibility using refresh header\n        if (statusCode === RedirectStatusCode.PermanentRedirect) {\n            this.setHeader('Refresh', `0;url=${destination}`);\n        }\n        return this;\n    }\n}\n\n//# sourceMappingURL=index.js.map","import { HeadersAdapter } from '../web/spec-extension/adapters/headers';\nimport { PRERENDER_REVALIDATE_HEADER, PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER } from '../../lib/constants';\nimport { getTracer } from '../lib/trace/tracer';\nimport { NodeSpan } from '../lib/trace/constants';\nexport function wrapApiHandler(page, handler) {\n    return (...args)=>{\n        getTracer().setRootSpanAttribute('next.route', page);\n        // Call API route method\n        return getTracer().trace(NodeSpan.runHandler, {\n            spanName: `executing api route (pages) ${page}`\n        }, ()=>handler(...args));\n    };\n}\n/**\n *\n * @param res response object\n * @param statusCode `HTTP` status code of response\n */ export function sendStatusCode(res, statusCode) {\n    res.statusCode = statusCode;\n    return res;\n}\n/**\n *\n * @param res response object\n * @param [statusOrUrl] `HTTP` status code of redirect\n * @param url URL of redirect\n */ export function redirect(res, statusOrUrl, url) {\n    if (typeof statusOrUrl === 'string') {\n        url = statusOrUrl;\n        statusOrUrl = 307;\n    }\n    if (typeof statusOrUrl !== 'number' || typeof url !== 'string') {\n        throw Object.defineProperty(new Error(`Invalid redirect arguments. Please use a single argument URL, e.g. res.redirect('/destination') or use a status code and URL, e.g. res.redirect(307, '/destination').`), \"__NEXT_ERROR_CODE\", {\n            value: \"E389\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    res.writeHead(statusOrUrl, {\n        Location: url\n    });\n    res.write(url);\n    res.end();\n    return res;\n}\nexport function checkIsOnDemandRevalidate(req, previewProps) {\n    const headers = HeadersAdapter.from(req.headers);\n    const previewModeId = headers.get(PRERENDER_REVALIDATE_HEADER);\n    const isOnDemandRevalidate = previewModeId === previewProps.previewModeId;\n    const revalidateOnlyGenerated = headers.has(PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER);\n    return {\n        isOnDemandRevalidate,\n        revalidateOnlyGenerated\n    };\n}\nexport const COOKIE_NAME_PRERENDER_BYPASS = `__prerender_bypass`;\nexport const COOKIE_NAME_PRERENDER_DATA = `__next_preview_data`;\nexport const RESPONSE_LIMIT_DEFAULT = 4 * 1024 * 1024;\nexport const SYMBOL_PREVIEW_DATA = Symbol(COOKIE_NAME_PRERENDER_DATA);\nexport const SYMBOL_CLEARED_COOKIES = Symbol(COOKIE_NAME_PRERENDER_BYPASS);\nexport function clearPreviewData(res, options = {}) {\n    if (SYMBOL_CLEARED_COOKIES in res) {\n        return res;\n    }\n    const { serialize } = require('next/dist/compiled/cookie');\n    const previous = res.getHeader('Set-Cookie');\n    res.setHeader(`Set-Cookie`, [\n        ...typeof previous === 'string' ? [\n            previous\n        ] : Array.isArray(previous) ? previous : [],\n        serialize(COOKIE_NAME_PRERENDER_BYPASS, '', {\n            // To delete a cookie, set `expires` to a date in the past:\n            // https://tools.ietf.org/html/rfc6265#section-4.1.1\n            // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.\n            expires: new Date(0),\n            httpOnly: true,\n            sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n            secure: process.env.NODE_ENV !== 'development',\n            path: '/',\n            ...options.path !== undefined ? {\n                path: options.path\n            } : undefined\n        }),\n        serialize(COOKIE_NAME_PRERENDER_DATA, '', {\n            // To delete a cookie, set `expires` to a date in the past:\n            // https://tools.ietf.org/html/rfc6265#section-4.1.1\n            // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.\n            expires: new Date(0),\n            httpOnly: true,\n            sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n            secure: process.env.NODE_ENV !== 'development',\n            path: '/',\n            ...options.path !== undefined ? {\n                path: options.path\n            } : undefined\n        })\n    ]);\n    Object.defineProperty(res, SYMBOL_CLEARED_COOKIES, {\n        value: true,\n        enumerable: false\n    });\n    return res;\n}\n/**\n * Custom error class\n */ export class ApiError extends Error {\n    constructor(statusCode, message){\n        super(message);\n        this.statusCode = statusCode;\n    }\n}\n/**\n * Sends error in `response`\n * @param res response object\n * @param statusCode of response\n * @param message of response\n */ export function sendError(res, statusCode, message) {\n    res.statusCode = statusCode;\n    res.statusMessage = message;\n    res.end(message);\n}\n/**\n * Execute getter function only if its needed\n * @param LazyProps `req` and `params` for lazyProp\n * @param prop name of property\n * @param getter function to get data\n */ export function setLazyProp({ req }, prop, getter) {\n    const opts = {\n        configurable: true,\n        enumerable: true\n    };\n    const optsReset = {\n        ...opts,\n        writable: true\n    };\n    Object.defineProperty(req, prop, {\n        ...opts,\n        get: ()=>{\n            const value = getter();\n            // we set the property on the object to avoid recalculating it\n            Object.defineProperty(req, prop, {\n                ...optsReset,\n                value\n            });\n            return value;\n        },\n        set: (value)=>{\n            Object.defineProperty(req, prop, {\n                ...optsReset,\n                value\n            });\n        }\n    });\n}\n\n//# sourceMappingURL=index.js.map","import { SYMBOL_CLEARED_COOKIES } from '../api-utils';\nimport { NEXT_REQUEST_META } from '../request-meta';\nimport { BaseNextRequest, BaseNextResponse } from './index';\nlet prop;\nexport class NodeNextRequest extends BaseNextRequest {\n    static #_ = prop = _NEXT_REQUEST_META = NEXT_REQUEST_META;\n    constructor(_req){\n        var _this__req;\n        super(_req.method.toUpperCase(), _req.url, _req), this._req = _req, this.headers = this._req.headers, this.fetchMetrics = (_this__req = this._req) == null ? void 0 : _this__req.fetchMetrics, this[_NEXT_REQUEST_META] = this._req[NEXT_REQUEST_META] || {}, this.streaming = false;\n    }\n    get originalRequest() {\n        // Need to mimic these changes to the original req object for places where we use it:\n        // render.tsx, api/ssg requests\n        this._req[NEXT_REQUEST_META] = this[NEXT_REQUEST_META];\n        this._req.url = this.url;\n        this._req.cookies = this.cookies;\n        return this._req;\n    }\n    set originalRequest(value) {\n        this._req = value;\n    }\n    /**\n   * Returns the request body as a Web Readable Stream. The body here can only\n   * be read once as the body will start flowing as soon as the data handler\n   * is attached.\n   *\n   * @internal\n   */ stream() {\n        if (this.streaming) {\n            throw Object.defineProperty(new Error('Invariant: NodeNextRequest.stream() can only be called once'), \"__NEXT_ERROR_CODE\", {\n                value: \"E467\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        this.streaming = true;\n        return new ReadableStream({\n            start: (controller)=>{\n                this._req.on('data', (chunk)=>{\n                    controller.enqueue(new Uint8Array(chunk));\n                });\n                this._req.on('end', ()=>{\n                    controller.close();\n                });\n                this._req.on('error', (err)=>{\n                    controller.error(err);\n                });\n            }\n        });\n    }\n}\nexport class NodeNextResponse extends BaseNextResponse {\n    get originalResponse() {\n        if (SYMBOL_CLEARED_COOKIES in this) {\n            this._res[SYMBOL_CLEARED_COOKIES] = this[SYMBOL_CLEARED_COOKIES];\n        }\n        return this._res;\n    }\n    constructor(_res){\n        super(_res), this._res = _res, this.textBody = undefined;\n    }\n    get sent() {\n        return this._res.finished || this._res.headersSent;\n    }\n    get statusCode() {\n        return this._res.statusCode;\n    }\n    set statusCode(value) {\n        this._res.statusCode = value;\n    }\n    get statusMessage() {\n        return this._res.statusMessage;\n    }\n    set statusMessage(value) {\n        this._res.statusMessage = value;\n    }\n    setHeader(name, value) {\n        this._res.setHeader(name, value);\n        return this;\n    }\n    removeHeader(name) {\n        this._res.removeHeader(name);\n        return this;\n    }\n    getHeaderValues(name) {\n        const values = this._res.getHeader(name);\n        if (values === undefined) return undefined;\n        return (Array.isArray(values) ? values : [\n            values\n        ]).map((value)=>value.toString());\n    }\n    hasHeader(name) {\n        return this._res.hasHeader(name);\n    }\n    getHeader(name) {\n        const values = this.getHeaderValues(name);\n        return Array.isArray(values) ? values.join(',') : undefined;\n    }\n    getHeaders() {\n        return this._res.getHeaders();\n    }\n    appendHeader(name, value) {\n        const currentValues = this.getHeaderValues(name) ?? [];\n        if (!currentValues.includes(value)) {\n            this._res.setHeader(name, [\n                ...currentValues,\n                value\n            ]);\n        }\n        return this;\n    }\n    body(value) {\n        this.textBody = value;\n        return this;\n    }\n    send() {\n        this._res.end(this.textBody);\n    }\n    onClose(callback) {\n        this.originalResponse.on('close', callback);\n    }\n}\nvar _NEXT_REQUEST_META;\n\n//# sourceMappingURL=node.js.map","/**\n * Parse cookies from the `headers` of request\n * @param req request object\n */ export function getCookieParser(headers) {\n    return function parseCookie() {\n        const { cookie } = headers;\n        if (!cookie) {\n            return {};\n        }\n        const { parse: parseCookieFn } = require('next/dist/compiled/cookie');\n        return parseCookieFn(Array.isArray(cookie) ? cookie.join('; ') : cookie);\n    };\n}\n\n//# sourceMappingURL=get-cookie-parser.js.map","import { ensureLeadingSlash } from '../../page-path/ensure-leading-slash';\nimport { isGroupSegment } from '../../segment';\n/**\n * Normalizes an app route so it represents the actual request path. Essentially\n * performing the following transformations:\n *\n * - `/(dashboard)/user/[id]/page` to `/user/[id]`\n * - `/(dashboard)/account/page` to `/account`\n * - `/user/[id]/page` to `/user/[id]`\n * - `/account/page` to `/account`\n * - `/page` to `/`\n * - `/(dashboard)/user/[id]/route` to `/user/[id]`\n * - `/(dashboard)/account/route` to `/account`\n * - `/user/[id]/route` to `/user/[id]`\n * - `/account/route` to `/account`\n * - `/route` to `/`\n * - `/` to `/`\n *\n * @param route the app route to normalize\n * @returns the normalized pathname\n */ export function normalizeAppPath(route) {\n    return ensureLeadingSlash(route.split('/').reduce((pathname, segment, index, segments)=>{\n        // Empty segments are ignored.\n        if (!segment) {\n            return pathname;\n        }\n        // Groups are ignored.\n        if (isGroupSegment(segment)) {\n            return pathname;\n        }\n        // Parallel segments are ignored.\n        if (segment[0] === '@') {\n            return pathname;\n        }\n        // The last segment (if it's a leaf) should be ignored.\n        if ((segment === 'page' || segment === 'route') && index === segments.length - 1) {\n            return pathname;\n        }\n        return pathname + \"/\" + segment;\n    }, ''));\n}\n/**\n * Strips the `.rsc` extension if it's in the pathname.\n * Since this function is used on full urls it checks `?` for searchParams handling.\n */ export function normalizeRscURL(url) {\n    return url.replace(/\\.rsc($|\\?)/, // $1 ensures `?` is preserved\n    '$1');\n}\n\n//# sourceMappingURL=app-paths.js.map","/**\n * For a given page path, this function ensures that there is a leading slash.\n * If there is not a leading slash, one is added, otherwise it is noop.\n */ export function ensureLeadingSlash(path) {\n    return path.startsWith('/') ? path : \"/\" + path;\n}\n\n//# sourceMappingURL=ensure-leading-slash.js.map","import { CACHE_ONE_YEAR } from '../../lib/constants'\n\n/**\n * The revalidate option used internally for pages. A value of `false` means\n * that the page should not be revalidated. A number means that the page\n * should be revalidated after the given number of seconds (this also includes\n * `1` which means to revalidate after 1 second). A value of `0` is not a valid\n * value for this option.\n */\nexport type Revalidate = number | false\n\nexport interface CacheControl {\n  revalidate: Revalidate\n  expire: number | undefined\n}\n\nexport function getCacheControlHeader({\n  revalidate,\n  expire,\n}: CacheControl): string {\n  const swrHeader =\n    typeof revalidate === 'number' &&\n    expire !== undefined &&\n    revalidate < expire\n      ? `, stale-while-revalidate=${expire - revalidate}`\n      : ''\n\n  if (revalidate === 0) {\n    return 'private, no-cache, no-store, max-age=0, must-revalidate'\n  } else if (typeof revalidate === 'number') {\n    return `s-maxage=${revalidate}${swrHeader}`\n  }\n\n  return `s-maxage=${CACHE_ONE_YEAR}${swrHeader}`\n}\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const MenuManagementClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call MenuManagementClient() from the server but MenuManagementClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/components/menu/menu-management-client.tsx\",\n    \"MenuManagementClient\",\n);\n","import { Suspense } from 'react';\nimport { PageHeader } from '@/components/ui/page-header';\nimport { MenuManagementClient } from '@/components/menu/menu-management-client';\nimport { getMenus, getSalesChannels, getAllergens } from '@/lib/menu/data';\n\nexport default async function MenuPage() {\n  // Fetch initial data\n  const [menusResult, channels, allergens] = await Promise.all([\n    getMenus({ page: 1, limit: 50 }),\n    getSalesChannels(),\n    getAllergens(),\n  ]);\n\n  return (\n    <div className=\"container mx-auto p-6\">\n      <PageHeader \n        title=\"Menu Management\" \n        description=\"Manage your restaurant menus, items, pricing, and availability\"\n      />\n      \n      <div className=\"mt-8\">\n        <Suspense fallback={<div>Loading menu management...</div>}>\n          <MenuManagementClient \n            initialMenus={menusResult.data}\n            availableChannels={channels}\n            availableAllergens={allergens}\n          />\n        </Suspense>\n      </div>\n    </div>\n  );\n}","import { \n  Menu, \n  MenuGroup, \n  MenuItem, \n  ModifierGroup,\n  ModifierOption,\n  SalesChannel,\n  Allergen,\n  MenuResponse,\n  MenuItemResponse,\n  MenuFilters,\n  CreateMenu,\n  CreateMenuGroup,\n  CreateMenuItem,\n  CreateModifierGroup,\n  CreateModifierOption,\n  UpdateMenu,\n  UpdateMenuGroup,\n  UpdateMenuItem,\n  UpdateModifierGroup,\n  UpdateModifierOption\n} from './types';\n\n// Mock data for development - replace with actual API calls\nconst delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\n// Sample data\nconst sampleAllergens: Allergen[] = [\n  { id: '1', name: 'Gluten', description: 'Contains gluten', severity: 'moderate' },\n  { id: '2', name: 'Dairy', description: 'Contains dairy products', severity: 'moderate' },\n  { id: '3', name: 'Nuts', description: 'Contains tree nuts', severity: 'severe' },\n  { id: '4', name: 'Shellfish', description: 'Contains shellfish', severity: 'severe' },\n  { id: '5', name: 'Eggs', description: 'Contains eggs', severity: 'mild' },\n];\n\nconst sampleChannels: SalesChannel[] = [\n  { id: 'dine-in', name: 'Dine In', type: 'dine_in', isActive: true },\n  { id: 'takeout', name: 'Takeout', type: 'takeout', isActive: true },\n  { id: 'delivery', name: 'Delivery', type: 'delivery', isActive: true },\n  { id: 'online', name: 'Online Ordering', type: 'online', isActive: true },\n];\n\nlet mockMenus: Menu[] = [\n  {\n    id: '1',\n    name: 'Main Menu',\n    description: 'Our signature dishes and classics',\n    type: 'main',\n    sortOrder: 1,\n    isActive: true,\n    createdAt: new Date('2024-01-01'),\n    updatedAt: new Date('2024-01-15'),\n    media: [],\n    channelVisibility: [\n      { channelId: 'dine-in', isVisible: true },\n      { channelId: 'takeout', isVisible: true },\n    ],\n    locationIds: [],\n    groups: [\n      {\n        id: 'group-1',\n        name: 'Appetizers',\n        description: 'Start your meal right',\n        sortOrder: 1,\n        isActive: true,\n        createdAt: new Date('2024-01-01'),\n        updatedAt: new Date('2024-01-10'),\n        media: [],\n        channelVisibility: [],\n        menuId: '1',\n        items: [\n          {\n            id: 'item-1',\n            name: 'Buffalo Wings',\n            description: 'Crispy wings tossed in our signature buffalo sauce',\n            basePrice: 12.99,\n            sortOrder: 1,\n            isActive: true,\n            isAvailable: true,\n            createdAt: new Date('2024-01-01'),\n            updatedAt: new Date('2024-01-05'),\n            pricingStrategies: [],\n            tags: ['spicy', 'popular'],\n            allergens: [],\n            dietaryRestrictions: [],\n            media: [],\n            channelVisibility: [],\n            modifierGroups: [\n              {\n                id: 'mod-group-1',\n                name: 'Sauce Options',\n                description: 'Choose your sauce',\n                isRequired: true,\n                minSelections: 1,\n                maxSelections: 1,\n                sortOrder: 1,\n                displayType: 'radio',\n                isActive: true,\n                createdAt: new Date('2024-01-01'),\n                updatedAt: new Date('2024-01-01'),\n                options: [\n                  {\n                    id: 'mod-opt-1',\n                    name: 'Buffalo',\n                    description: 'Classic buffalo sauce',\n                    price: 0,\n                    sortOrder: 1,\n                    isDefault: true,\n                    isActive: true,\n                    createdAt: new Date('2024-01-01'),\n                    updatedAt: new Date('2024-01-01'),\n                    pricingStrategies: [],\n                    allergens: [],\n                    media: [],\n                  },\n                  {\n                    id: 'mod-opt-2',\n                    name: 'BBQ',\n                    description: 'Sweet and smoky BBQ sauce',\n                    price: 0,\n                    sortOrder: 2,\n                    isDefault: false,\n                    isActive: true,\n                    createdAt: new Date('2024-01-01'),\n                    updatedAt: new Date('2024-01-01'),\n                    pricingStrategies: [],\n                    allergens: [],\n                    media: [],\n                  }\n                ]\n              }\n            ]\n          }\n        ],\n        subGroups: []\n      }\n    ]\n  }\n];\n\n// API Functions\n\nexport async function getMenus(params?: {\n  page?: number;\n  limit?: number;\n  search?: string;\n  isActive?: boolean;\n}): Promise<MenuResponse> {\n  await delay(100);\n  \n  let filtered = [...mockMenus];\n  \n  // Apply filters\n  if (params?.search) {\n    const search = params.search.toLowerCase();\n    filtered = filtered.filter(menu => \n      menu.name.toLowerCase().includes(search) ||\n      menu.description?.toLowerCase().includes(search)\n    );\n  }\n  \n  if (params?.isActive !== undefined) {\n    filtered = filtered.filter(menu => menu.isActive === params.isActive);\n  }\n  \n  // Pagination\n  const page = params?.page || 1;\n  const limit = params?.limit || 10;\n  const start = (page - 1) * limit;\n  const end = start + limit;\n  \n  return {\n    data: filtered.slice(start, end),\n    total: filtered.length,\n    page,\n    limit,\n  };\n}\n\nexport async function getMenu(id: string): Promise<Menu | null> {\n  await delay(100);\n  return mockMenus.find(menu => menu.id === id) || null;\n}\n\nexport async function createMenu(data: CreateMenu): Promise<Menu> {\n  await delay(200);\n  \n  const newMenu: Menu = {\n    ...data,\n    id: `menu-${Date.now()}`,\n    createdAt: new Date(),\n    updatedAt: new Date(),\n    groups: [],\n  };\n  \n  mockMenus.push(newMenu);\n  return newMenu;\n}\n\nexport async function updateMenu(id: string, data: UpdateMenu): Promise<Menu | null> {\n  await delay(200);\n  \n  const index = mockMenus.findIndex(menu => menu.id === id);\n  if (index === -1) return null;\n  \n  mockMenus[index] = {\n    ...mockMenus[index],\n    ...data,\n    updatedAt: new Date(),\n  };\n  \n  return mockMenus[index];\n}\n\nexport async function deleteMenu(id: string): Promise<boolean> {\n  await delay(200);\n  \n  const index = mockMenus.findIndex(menu => menu.id === id);\n  if (index === -1) return false;\n  \n  mockMenus.splice(index, 1);\n  return true;\n}\n\n// Menu Groups\nexport async function getMenuGroups(menuId: string): Promise<MenuGroup[]> {\n  await delay(100);\n  \n  const menu = mockMenus.find(m => m.id === menuId);\n  return menu?.groups || [];\n}\n\nexport async function getMenuGroup(id: string): Promise<MenuGroup | null> {\n  await delay(100);\n  \n  for (const menu of mockMenus) {\n    const group = findGroupRecursive(menu.groups, id);\n    if (group) return group;\n  }\n  \n  return null;\n}\n\nfunction findGroupRecursive(groups: MenuGroup[], id: string): MenuGroup | null {\n  for (const group of groups) {\n    if (group.id === id) return group;\n    \n    const found = findGroupRecursive(group.subGroups, id);\n    if (found) return found;\n  }\n  return null;\n}\n\nexport async function createMenuGroup(data: CreateMenuGroup): Promise<MenuGroup> {\n  await delay(200);\n  \n  const newGroup: MenuGroup = {\n    ...data,\n    id: `group-${Date.now()}`,\n    createdAt: new Date(),\n    updatedAt: new Date(),\n    items: [],\n    subGroups: [],\n  };\n  \n  // Add to appropriate menu\n  const menu = mockMenus.find(m => m.id === data.menuId);\n  if (menu) {\n    if (data.parentGroupId) {\n      const parentGroup = findGroupRecursive(menu.groups, data.parentGroupId);\n      if (parentGroup) {\n        parentGroup.subGroups.push(newGroup);\n      }\n    } else {\n      menu.groups.push(newGroup);\n    }\n  }\n  \n  return newGroup;\n}\n\nexport async function updateMenuGroup(id: string, data: UpdateMenuGroup): Promise<MenuGroup | null> {\n  await delay(200);\n  \n  for (const menu of mockMenus) {\n    const group = findGroupRecursive(menu.groups, id);\n    if (group) {\n      Object.assign(group, {\n        ...data,\n        updatedAt: new Date(),\n      });\n      return group;\n    }\n  }\n  \n  return null;\n}\n\nexport async function deleteMenuGroup(id: string): Promise<boolean> {\n  await delay(200);\n  \n  for (const menu of mockMenus) {\n    if (removeGroupRecursive(menu.groups, id)) {\n      return true;\n    }\n  }\n  \n  return false;\n}\n\nfunction removeGroupRecursive(groups: MenuGroup[], id: string): boolean {\n  const index = groups.findIndex(group => group.id === id);\n  if (index !== -1) {\n    groups.splice(index, 1);\n    return true;\n  }\n  \n  for (const group of groups) {\n    if (removeGroupRecursive(group.subGroups, id)) {\n      return true;\n    }\n  }\n  \n  return false;\n}\n\n// Menu Items\nexport async function getMenuItems(params?: {\n  page?: number;\n  limit?: number;\n  menuId?: string;\n  groupId?: string;\n  filters?: MenuFilters;\n}): Promise<MenuItemResponse> {\n  await delay(100);\n  \n  let items: MenuItem[] = [];\n  \n  // Collect all items\n  for (const menu of mockMenus) {\n    if (params?.menuId && menu.id !== params.menuId) continue;\n    \n    collectItemsRecursive(menu.groups, items, params?.groupId);\n  }\n  \n  // Apply filters\n  if (params?.filters) {\n    items = applyMenuItemFilters(items, params.filters);\n  }\n  \n  // Pagination\n  const page = params?.page || 1;\n  const limit = params?.limit || 20;\n  const start = (page - 1) * limit;\n  const end = start + limit;\n  \n  return {\n    data: items.slice(start, end),\n    total: items.length,\n    page,\n    limit,\n  };\n}\n\nfunction collectItemsRecursive(\n  groups: MenuGroup[], \n  items: MenuItem[], \n  targetGroupId?: string\n): void {\n  for (const group of groups) {\n    if (!targetGroupId || group.id === targetGroupId) {\n      items.push(...group.items);\n    }\n    \n    if (!targetGroupId) {\n      collectItemsRecursive(group.subGroups, items);\n    }\n  }\n}\n\nfunction applyMenuItemFilters(items: MenuItem[], filters: MenuFilters): MenuItem[] {\n  return items.filter(item => {\n    if (filters.search) {\n      const search = filters.search.toLowerCase();\n      if (!item.name.toLowerCase().includes(search) &&\n          !item.description?.toLowerCase().includes(search)) {\n        return false;\n      }\n    }\n    \n    if (filters.isActive !== undefined && item.isActive !== filters.isActive) {\n      return false;\n    }\n    \n    if (filters.isAvailable !== undefined && item.isAvailable !== filters.isAvailable) {\n      return false;\n    }\n    \n    if (filters.priceRange) {\n      if (item.basePrice < filters.priceRange[0] || item.basePrice > filters.priceRange[1]) {\n        return false;\n      }\n    }\n    \n    if (filters.allergens?.length) {\n      const hasAllergen = filters.allergens.some(allergen => \n        item.allergens.includes(allergen)\n      );\n      if (hasAllergen) return false;\n    }\n    \n    if (filters.tags?.length) {\n      const hasTag = filters.tags.some(tag => item.tags.includes(tag));\n      if (!hasTag) return false;\n    }\n    \n    return true;\n  });\n}\n\nexport async function getMenuItem(id: string): Promise<MenuItem | null> {\n  await delay(100);\n  \n  for (const menu of mockMenus) {\n    const item = findItemRecursive(menu.groups, id);\n    if (item) return item;\n  }\n  \n  return null;\n}\n\nfunction findItemRecursive(groups: MenuGroup[], id: string): MenuItem | null {\n  for (const group of groups) {\n    const item = group.items.find(item => item.id === id);\n    if (item) return item;\n    \n    const found = findItemRecursive(group.subGroups, id);\n    if (found) return found;\n  }\n  return null;\n}\n\nexport async function createMenuItem(data: CreateMenuItem): Promise<MenuItem> {\n  await delay(200);\n  \n  const newItem: MenuItem = {\n    ...data,\n    id: `item-${Date.now()}`,\n    createdAt: new Date(),\n    updatedAt: new Date(),\n    modifierGroups: [],\n  };\n  \n  // Add to appropriate group\n  if (data.menuGroupId) {\n    for (const menu of mockMenus) {\n      const group = findGroupRecursive(menu.groups, data.menuGroupId);\n      if (group) {\n        group.items.push(newItem);\n        break;\n      }\n    }\n  }\n  \n  return newItem;\n}\n\nexport async function updateMenuItem(id: string, data: UpdateMenuItem): Promise<MenuItem | null> {\n  await delay(200);\n  \n  for (const menu of mockMenus) {\n    const item = findItemRecursive(menu.groups, id);\n    if (item) {\n      Object.assign(item, {\n        ...data,\n        updatedAt: new Date(),\n      });\n      return item;\n    }\n  }\n  \n  return null;\n}\n\nexport async function deleteMenuItem(id: string): Promise<boolean> {\n  await delay(200);\n  \n  for (const menu of mockMenus) {\n    if (removeItemRecursive(menu.groups, id)) {\n      return true;\n    }\n  }\n  \n  return false;\n}\n\nfunction removeItemRecursive(groups: MenuGroup[], id: string): boolean {\n  for (const group of groups) {\n    const index = group.items.findIndex(item => item.id === id);\n    if (index !== -1) {\n      group.items.splice(index, 1);\n      return true;\n    }\n    \n    if (removeItemRecursive(group.subGroups, id)) {\n      return true;\n    }\n  }\n  \n  return false;\n}\n\n// Modifier Groups\nexport async function getModifierGroups(itemId: string): Promise<ModifierGroup[]> {\n  await delay(100);\n  \n  const item = await getMenuItem(itemId);\n  return item?.modifierGroups || [];\n}\n\nexport async function createModifierGroup(\n  itemId: string, \n  data: CreateModifierGroup\n): Promise<ModifierGroup> {\n  await delay(200);\n  \n  const newGroup: ModifierGroup = {\n    ...data,\n    id: `mod-group-${Date.now()}`,\n    createdAt: new Date(),\n    updatedAt: new Date(),\n    options: [],\n  };\n  \n  // Add to item\n  const item = await getMenuItem(itemId);\n  if (item) {\n    item.modifierGroups.push(newGroup);\n  }\n  \n  return newGroup;\n}\n\nexport async function updateModifierGroup(\n  id: string, \n  data: UpdateModifierGroup\n): Promise<ModifierGroup | null> {\n  await delay(200);\n  \n  for (const menu of mockMenus) {\n    const group = findModifierGroupRecursive(menu.groups, id);\n    if (group) {\n      Object.assign(group, {\n        ...data,\n        updatedAt: new Date(),\n      });\n      return group;\n    }\n  }\n  \n  return null;\n}\n\nfunction findModifierGroupRecursive(\n  menuGroups: MenuGroup[], \n  id: string\n): ModifierGroup | null {\n  for (const group of menuGroups) {\n    for (const item of group.items) {\n      const modGroup = item.modifierGroups.find(mg => mg.id === id);\n      if (modGroup) return modGroup;\n    }\n    \n    const found = findModifierGroupRecursive(group.subGroups, id);\n    if (found) return found;\n  }\n  return null;\n}\n\nexport async function deleteModifierGroup(id: string): Promise<boolean> {\n  await delay(200);\n  \n  for (const menu of mockMenus) {\n    if (removeModifierGroupRecursive(menu.groups, id)) {\n      return true;\n    }\n  }\n  \n  return false;\n}\n\nfunction removeModifierGroupRecursive(menuGroups: MenuGroup[], id: string): boolean {\n  for (const group of menuGroups) {\n    for (const item of group.items) {\n      const index = item.modifierGroups.findIndex(mg => mg.id === id);\n      if (index !== -1) {\n        item.modifierGroups.splice(index, 1);\n        return true;\n      }\n    }\n    \n    if (removeModifierGroupRecursive(group.subGroups, id)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Modifier Options\nexport async function createModifierOption(\n  groupId: string,\n  data: CreateModifierOption\n): Promise<ModifierOption> {\n  await delay(200);\n  \n  const newOption: ModifierOption = {\n    ...data,\n    id: `mod-opt-${Date.now()}`,\n    createdAt: new Date(),\n    updatedAt: new Date(),\n  };\n  \n  // Add to group\n  const group = await getModifierGroup(groupId);\n  if (group) {\n    group.options.push(newOption);\n  }\n  \n  return newOption;\n}\n\nexport async function getModifierGroup(id: string): Promise<ModifierGroup | null> {\n  await delay(100);\n  \n  for (const menu of mockMenus) {\n    const group = findModifierGroupRecursive(menu.groups, id);\n    if (group) return group;\n  }\n  \n  return null;\n}\n\nexport async function updateModifierOption(\n  id: string,\n  data: UpdateModifierOption\n): Promise<ModifierOption | null> {\n  await delay(200);\n  \n  for (const menu of mockMenus) {\n    const option = findModifierOptionRecursive(menu.groups, id);\n    if (option) {\n      Object.assign(option, {\n        ...data,\n        updatedAt: new Date(),\n      });\n      return option;\n    }\n  }\n  \n  return null;\n}\n\nfunction findModifierOptionRecursive(\n  menuGroups: MenuGroup[], \n  id: string\n): ModifierOption | null {\n  for (const group of menuGroups) {\n    for (const item of group.items) {\n      for (const modGroup of item.modifierGroups) {\n        const option = modGroup.options.find(opt => opt.id === id);\n        if (option) return option;\n      }\n    }\n    \n    const found = findModifierOptionRecursive(group.subGroups, id);\n    if (found) return found;\n  }\n  return null;\n}\n\nexport async function deleteModifierOption(id: string): Promise<boolean> {\n  await delay(200);\n  \n  for (const menu of mockMenus) {\n    if (removeModifierOptionRecursive(menu.groups, id)) {\n      return true;\n    }\n  }\n  \n  return false;\n}\n\nfunction removeModifierOptionRecursive(menuGroups: MenuGroup[], id: string): boolean {\n  for (const group of menuGroups) {\n    for (const item of group.items) {\n      for (const modGroup of item.modifierGroups) {\n        const index = modGroup.options.findIndex(opt => opt.id === id);\n        if (index !== -1) {\n          modGroup.options.splice(index, 1);\n          return true;\n        }\n      }\n    }\n    \n    if (removeModifierOptionRecursive(group.subGroups, id)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Utility functions\nexport async function getSalesChannels(): Promise<SalesChannel[]> {\n  await delay(50);\n  return [...sampleChannels];\n}\n\nexport async function getAllergens(): Promise<Allergen[]> {\n  await delay(50);\n  return [...sampleAllergens];\n}\n\nexport async function reorderItems(\n  groupId: string, \n  itemIds: string[]\n): Promise<boolean> {\n  await delay(200);\n  \n  const group = await getMenuGroup(groupId);\n  if (!group) return false;\n  \n  // Update sort orders based on new position\n  group.items.sort((a, b) => {\n    const aIndex = itemIds.indexOf(a.id);\n    const bIndex = itemIds.indexOf(b.id);\n    return aIndex - bIndex;\n  });\n  \n  group.items.forEach((item, index) => {\n    item.sortOrder = index + 1;\n    item.updatedAt = new Date();\n  });\n  \n  return true;\n}\n\nexport async function reorderGroups(\n  menuId: string, \n  groupIds: string[]\n): Promise<boolean> {\n  await delay(200);\n  \n  const menu = await getMenu(menuId);\n  if (!menu) return false;\n  \n  // Update sort orders based on new position\n  menu.groups.sort((a, b) => {\n    const aIndex = groupIds.indexOf(a.id);\n    const bIndex = groupIds.indexOf(b.id);\n    return aIndex - bIndex;\n  });\n  \n  menu.groups.forEach((group, index) => {\n    group.sortOrder = index + 1;\n    group.updatedAt = new Date();\n  });\n  \n  return true;\n}\n\nexport async function moveItem(\n  itemId: string, \n  targetGroupId: string\n): Promise<boolean> {\n  await delay(200);\n  \n  // Find and remove item from current location\n  let item: MenuItem | null = null;\n  for (const menu of mockMenus) {\n    if (removeItemRecursive(menu.groups, itemId)) {\n      item = await getMenuItem(itemId);\n      break;\n    }\n  }\n  \n  if (!item) return false;\n  \n  // Add to new group\n  const targetGroup = await getMenuGroup(targetGroupId);\n  if (!targetGroup) return false;\n  \n  item.menuGroupId = targetGroupId;\n  item.updatedAt = new Date();\n  targetGroup.items.push(item);\n  \n  return true;\n}\n\n// Bulk operations\nexport async function bulkUpdateItems(\n  itemIds: string[],\n  updates: Partial<UpdateMenuItem>\n): Promise<MenuItem[]> {\n  await delay(300);\n  \n  const updatedItems: MenuItem[] = [];\n  \n  for (const itemId of itemIds) {\n    const item = await updateMenuItem(itemId, updates);\n    if (item) {\n      updatedItems.push(item);\n    }\n  }\n  \n  return updatedItems;\n}\n\nexport async function bulkDeleteItems(itemIds: string[]): Promise<boolean> {\n  await delay(300);\n  \n  let allDeleted = true;\n  \n  for (const itemId of itemIds) {\n    const deleted = await deleteMenuItem(itemId);\n    if (!deleted) {\n      allDeleted = false;\n    }\n  }\n  \n  return allDeleted;\n}"],"names":["getRevalidateReason","params","isOnDemandRevalidate","isRevalidate","undefined","CACHE_ONE_YEAR","getCacheControlHeader","revalidate","expire","swrHeader"],"mappings":"8LAAO,SAASA,EAAoBC,CAGnC,SACKA,AAAJ,EAAWC,oBAAoB,CACtB,CADwB,WAG7BD,EAAOE,YAAY,CACd,CADgB,aAI3B,0HCXA,IG0HI,EH1HJ,EAAA,EAAA,CAAA,CAAA,MAGW,MGyHX,CHzHiB,UAA6B,MAC1C,aAAa,CACT,CGuHwB,IHvHnB,CAAC,qGACV,CACA,OAAO,UAAW,CACd,MAAM,IAAI,CACd,CACJ,CACO,MAAM,UAAuB,QAChC,YAAY,CAAO,CAAC,CAGhB,KAAK,GACL,IAAI,CAAC,OAAO,CAAG,IAAI,MAAM,EAAS,CAC9B,IAAK,CAAM,CAAE,CAAI,CAAE,CAAQ,EAIvB,GAAoB,UAAhB,AAA0B,OAAnB,EACP,OAAO,EAAA,cAAc,CAAC,GAAG,CAAC,EAAQ,EAAM,GAE5C,IAAM,EAAa,EAAK,WAAW,GAI7B,EAAW,OAAO,IAAI,CAAC,GAAS,IAAI,CAAC,AAAC,GAAI,EAAE,WAAW,KAAO,GAEpE,GAAI,AAAoB,SAAb,EAEX,EAFqC,KAE9B,EAAA,cAAc,CAAC,GAAG,CAAC,EAAQ,EAAU,EAChD,EACA,IAAK,CAAM,CAAE,CAAI,CAAE,CAAK,CAAE,CAAQ,EAC9B,GAAoB,AAAhB,UAA0B,OAAnB,EACP,OAAO,EAAA,cAAc,CAAC,GAAG,CAAC,EAAQ,EAAM,EAAO,GAEnD,IAAM,EAAa,EAAK,WAAW,GAI7B,EAAW,OAAO,IAAI,CAAC,GAAS,IAAI,CAAC,AAAC,GAAI,EAAE,WAAW,KAAO,GAEpE,OAAO,EAAA,cAAc,CAAC,GAAG,CAAC,EAAQ,GAAY,EAAM,EAAO,EAC/D,EACA,IAAK,CAAM,CAAE,CAAI,EACb,GAAoB,UAAhB,OAAO,EAAmB,OAAO,EAAA,cAAc,CAAC,GAAG,CAAC,EAAQ,GAChE,IAAM,EAAa,EAAK,WAAW,GAI7B,EAAW,OAAO,IAAI,CAAC,GAAS,IAAI,CAAC,AAAC,GAAI,EAAE,WAAW,KAAO,UAEpE,IAAI,CAAoB,IAAb,GAEJ,EAAA,IAF8B,OAAO,GAEvB,CAAC,GAAG,CAAC,EAAQ,EACtC,EACA,eAAgB,CAAM,CAAE,CAAI,EACxB,GAAI,AAAgB,iBAAT,EAAmB,OAAO,EAAA,cAAc,CAAC,cAAc,CAAC,EAAQ,GAC3E,IAAM,EAAa,EAAK,WAAW,GAI7B,EAAW,OAAO,IAAI,CAAC,GAAS,IAAI,CAAC,AAAC,GAAI,EAAE,WAAW,KAAO,UAEpE,IAAI,CAAoB,IAAb,GAEJ,EAAA,IAF8B,OAAO,GAEvB,CAAC,cAAc,CAAC,EAAQ,EACjD,CACJ,EACJ,CAIE,OAAO,KAAK,CAAO,CAAE,CACnB,OAAO,IAAI,MAAM,EAAS,CACtB,IAAK,CAAM,CAAE,CAAI,CAAE,CAAQ,EACvB,OAAO,GACH,IAAK,SACL,IAAK,SACL,IAAK,MACD,OAAO,EAAqB,QAAQ,AACxC,SACI,OAAO,EAAA,cAAc,CAAC,GAAG,CAAC,EAAQ,EAAM,EAChD,CACJ,CACJ,EACJ,CAOE,MAAM,CAAK,CAAE,QACX,AAAI,MAAM,OAAO,CAAC,GAAe,EAAM,GAAb,CAAiB,CAAC,MACrC,CACX,CAME,OAAO,KAAK,CAAO,CAAE,QACnB,AAAI,aAAmB,QAAgB,CAAP,CACzB,IAAI,EAAe,EAC9B,CACA,OAAO,CAAI,CAAE,CAAK,CAAE,CAChB,IAAM,EAAW,IAAI,CAAC,OAAO,CAAC,EAAK,CACX,UAAU,AAA9B,OAAO,EACP,IAAI,CAAC,OAAO,CAAC,EAAK,CAAG,CACjB,EACA,EACH,CACM,MAAM,OAAO,CAAC,GACrB,EAAS,IAAI,CAAC,CADkB,EAGhC,IAAI,CAAC,OAAO,CAAC,EAAK,CAAG,CAE7B,CACA,OAAO,CAAI,CAAE,CACT,OAAO,IAAI,CAAC,OAAO,CAAC,EAAK,AAC7B,CACA,IAAI,CAAI,CAAE,CACN,IAAM,EAAQ,IAAI,CAAC,OAAO,CAAC,EAAK,QAChC,AAAI,KAAiB,IAAV,EAA8B,IAAI,CAAC,EAAZ,GAAiB,CAAC,GAC7C,IACX,CACA,IAAI,CAAI,CAAE,CACN,OAAO,KAA8B,IAAvB,IAAI,CAAC,OAAO,CAAC,EAAK,AACpC,CACA,IAAI,CAAI,CAAE,CAAK,CAAE,CACb,IAAI,CAAC,OAAO,CAAC,EAAK,CAAG,CACzB,CACA,QAAQ,CAAU,CAAE,CAAO,CAAE,CACzB,IAAK,GAAM,CAAC,EAAM,EAAM,GAAI,IAAI,CAAC,OAAO,GAAG,AACvC,EAAW,IAAI,CAAC,EAAS,EAAO,EAAM,IAAI,CAElD,CACA,CAAC,SAAU,CACP,IAAK,IAAM,KAAO,OAAO,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CACxC,IAAM,EAAO,EAAI,WAAW,GAGtB,EAAQ,IAAI,CAAC,GAAG,CAAC,EACvB,MAAM,CACF,EACA,EACH,AACL,CACJ,CACA,CAAC,MAAO,CACJ,IAAK,IAAM,KAAO,OAAO,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CACxC,IAAM,EAAO,EAAI,WAAW,EAC5B,OAAM,CACV,CACJ,CACA,CAAC,QAAS,CACN,IAAK,IAAM,KAAO,OAAO,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAGxC,IAAM,EAAQ,IAAI,CAAC,GAAG,CAAC,EACvB,OAAM,CACV,CACJ,CACA,CAAC,OAAO,QAAQ,CAAC,EAAG,CAChB,OAAO,IAAI,CAAC,OAAO,EACvB,CACJ,CExKA,CF0KA,CE1KA,CAAA,CAAA,OACA,EAAA,CAAA,CAAA,OACA,EAAA,CAAA,CAAA,OAuDmC,GFiHA,IEnHO,AAEA,CAFC,mBAAmB,CAAC,EAGxD,IAAM,EAAyB,OAAO,AAJD,CAAC,kBAAkB,CAAC,ECtDhE,IAAA,EAAA,EAAA,CAAA,CAAA,OFDA,EAAA,EAAA,CAAA,CAAA,MAEO,OAAM,EACT,YAAY,CAAM,CAAE,CAAG,CAAE,CAAI,CAAC,CAC1B,IAAI,CAAC,MAAM,CAAG,EACd,IAAI,CAAC,GAAG,CAAG,EACX,IAAI,CAAC,IAAI,CAAG,CAChB,CAEA,IAAI,SAAU,cACV,AAAI,IAAI,CAAC,QAAQ,CAAS,CAAP,GAAW,CAAC,QAAQ,CAChC,IAAI,CAAC,QAAQ,CAAG,CGRK,EHQW,IAAI,CGRR,AHQS,OAAO,CGPhD,SAAS,EACZ,GAAM,QAAE,CAAM,CAAE,CAAG,EACnB,GAAI,CAAC,EACD,MAAO,AADE,CACD,EAEZ,GAAM,CAAE,MAAO,CAAa,CAAE,CAAA,EAAA,CAAA,CAAA,OAC9B,OAAO,EAAc,MAAM,OAAO,CAAC,GAAU,EAAO,IAAI,CAAC,MAAQ,EACrE,IHCA,CACJ,CACO,MAAM,EACT,YAAY,CAAW,CAAC,CACpB,IAAI,CAAC,WAAW,CAAG,CACvB,CAEA,SAAS,CAAW,CAAE,CAAU,CAAE,CAQ9B,OAPA,IAAI,CAAC,SAAS,CAAC,WAAY,GAC3B,IAAI,CAAC,UAAU,CAAG,EAGd,IAAe,EAAA,kBAAkB,CAAC,iBAAiB,EAAE,AACrD,IAAI,CAAC,SAAS,CAAC,UAAW,CAAC,MAAM,EAAE,EAAA,CAAa,EAE7C,IAAI,AACf,CACJ,CEzBO,CF2BP,KE3Ba,UAAwB,EACjC,QAAO,CAAA,AAAE,CAAU,EAAP,AAA4B,EAAA,EF0BX,eEzB7B,AADyD,AAAC,aAC9C,CAAI,CAAC,CACb,IAAI,EACJ,KAAK,CAAC,EAAK,MAAM,CAAC,WAAW,GAAI,EAAK,GAAG,CAAE,GAAO,IAAI,CAAC,IAAI,CAAG,EAAM,IAAI,CAAC,OAAO,CAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAE,IAAI,CAAC,YAAY,CAA+B,AAA5B,OAAC,EAAa,IAAI,CAAC,IAAI,AAAJ,EAAgB,KAAK,EAAI,EAAW,YAAY,CAAE,IAAI,CAAC,EAAmB,CAAG,IAAI,CAAC,IAAI,CAAC,EAAA,iBAAiB,CAAC,EAAI,CAAC,EAAG,IAAI,CAAC,SAAS,EAAG,CACnR,CACA,IAAI,iBAAkB,CAMlB,OAHA,IAAI,CAAC,IAAI,CAAC,EAAA,iBAAiB,CAAC,CAAG,IAAI,CAAC,EAAA,iBAAiB,CAAC,CACtD,IAAI,CAAC,IAAI,CAAC,GAAG,CAAG,IAAI,CAAC,GAAG,CACxB,IAAI,CAAC,IAAI,CAAC,OAAO,CAAG,IAAI,CAAC,OAAO,CACzB,IAAI,CAAC,IAAI,AACpB,CACA,IAAI,gBAAgB,CAAK,CAAE,CACvB,IAAI,CAAC,IAAI,CAAG,CAChB,CAOE,QAAS,CACP,GAAI,IAAI,CAAC,SAAS,CACd,CADgB,KACV,OAAO,cAAc,CAAC,AAAI,MAAM,+DAAgE,oBAAqB,CACvH,MAAO,OACP,YAAY,EACZ,cAAc,CAClB,GAGJ,OADA,IAAI,CAAC,SAAS,EAAG,EACV,IAAI,eAAe,CACtB,MAAQ,AAAD,IACH,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,OAAQ,AAAC,IAClB,EAAW,OAAO,CAAC,IAAI,WAAW,GACtC,GACA,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,MAAO,KAChB,EAAW,KAAK,EACpB,GACA,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,QAAS,AAAC,IACnB,EAAW,KAAK,CAAC,EACrB,EACJ,CACJ,EACJ,CACJ,CACO,MAAM,UAAyB,EAClC,IAAI,kBAAmB,CAInB,OAHI,KAA0B,IAAI,EAAE,CAChC,IAAI,CAAC,IAAI,CAAC,EAAuB,CAAG,IAAI,CAAC,EAAA,AAAuB,EAE7D,IAAI,CAAC,IAChB,AADoB,CAEpB,YAAY,CAAI,CAAC,CACb,KAAK,CAAC,GAAO,IAAI,CAAC,IAAI,CAAG,EAAM,IAAI,CAAC,QAAQ,MAAG,CACnD,CACA,IAAI,MAAO,CACP,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAI,IAAI,CAAC,IAAI,CAAC,WAC3C,AADsD,CAEtD,IAAI,YAAa,CACb,OAAO,IAAI,CAAC,IAAI,CAAC,UAAU,AAC/B,CACA,IAAI,WAAW,CAAK,CAAE,CAClB,IAAI,CAAC,IAAI,CAAC,UAAU,CAAG,CAC3B,CACA,IAAI,eAAgB,CAChB,OAAO,IAAI,CAAC,IAAI,CAAC,aAAa,AAClC,CACA,IAAI,cAAc,CAAK,CAAE,CACrB,IAAI,CAAC,IAAI,CAAC,aAAa,CAAG,CAC9B,CACA,UAAU,CAAI,CAAE,CAAK,CAAE,CAEnB,OADA,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,EAAM,GACnB,IAAI,AACf,CACA,aAAa,CAAI,CAAE,CAEf,OADA,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,GAChB,IAAI,AACf,CACA,gBAAgB,CAAI,CAAE,CAClB,IAAM,EAAS,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,GACnC,GAAe,SAAX,EACJ,AAD0B,MACnB,CAAC,AADyB,MACnB,OAAO,CAAC,GAAU,EAAS,CACrC,EACH,EAAE,GAAG,CAAC,AAAC,GAAQ,EAAM,QAAQ,GAClC,CACA,UAAU,CAAI,CAAE,CACZ,OAAO,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,EAC/B,CACA,UAAU,CAAI,CAAE,CACZ,IAAM,EAAS,IAAI,CAAC,eAAe,CAAC,GACpC,OAAO,MAAM,OAAO,CAAC,GAAU,EAAO,IAAI,CAAC,UAAO,CACtD,CACA,YAAa,CACT,OAAO,IAAI,CAAC,IAAI,CAAC,UAAU,EAC/B,CACA,aAAa,CAAI,CAAE,CAAK,CAAE,CACtB,IAAM,EAAgB,IAAI,CAAC,eAAe,CAAC,IAAS,EAAE,CAOtD,OANI,AAAC,EAAc,QAAQ,CAAC,IACxB,IADgC,AAC5B,CAAC,IAAI,CAAC,SAAS,CAAC,EAAM,IACnB,EACH,EACH,EAEE,IAAI,AACf,CACA,KAAK,CAAK,CAAE,CAER,OADA,IAAI,CAAC,QAAQ,CAAG,EACT,IAAI,AACf,CACA,MAAO,CACH,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,CAC/B,CACA,QAAQ,CAAQ,CAAE,CACd,IAAI,CAAC,gBAAgB,CAAC,EAAE,CAAC,QAAS,EACtC,CACJ,gEExHA,IAAA,EAAA,EAAA,CAAA,CAAA,OAmBW,SAAS,EAAiB,CAAK,QACtC,MCjBO,CDiBA,AClB4B,EDkBT,EClBa,ADkBP,KAAK,CAAC,KAAK,MAAM,CAAC,CAAC,EAAU,EAAS,EAAO,IAEzE,AAAI,CAAC,GAID,CAAA,EAAA,EAAA,CAJU,aAIV,AAAc,EAAC,IAIA,KAAK,CAJK,AAIzB,CAAO,CAAC,EAAE,EAIV,CAAa,SAAZ,GAAkC,UAAZ,CAAY,CAAO,EAAK,IAAU,EAAS,MAAM,CAAG,EAXpE,CAWuE,CAG3E,EAAW,IAAM,EACzB,KCnCS,UAAU,CAAC,KAAO,EAAO,IAAM,CDoC/C,+DExCA,IAAA,EAA+B,EAAqB,CAAA,AAA3CE,CAA2C,IAAA,GAgB7C,MAhBgB,GAgBPC,EAAsB,CACpCC,EAjB6B,UAiBnB,CACVC,QAAM,CACO,EACb,IAAMC,EACkB,UAAtB,OAAOF,QACIH,IAAXI,GACAD,EAAaC,EACT,CAAC,yBAAyB,EAAEA,EAASD,EAAAA,CAAY,CACjD,UAEN,AAAIA,AAAe,GAAG,GACb,0DACwB,UAAtB,AAAgC,OAAzBA,EACT,CAAC,SAAS,EAAEA,EAAAA,EAAaE,EAAAA,CAAW,CAGtC,CAAC,SAAS,EAAEJ,EAAAA,cAAAA,CAAAA,EAAiBI,EAAAA,CAAW,AACjD,2GChCO,IAAM,EAAuB,CAAA,EADpC,AACoC,EADpC,CAAA,CAAA,OACoC,uBAAA,AAAuB,EACvD,WAAa,MAAU,AAAJ,MAAU,sPAAwP,EACrR,2EACA,oFAHG,IAAM,EAAuB,CAAA,EADpC,AACoC,EADpC,CAAA,CAAA,OACoC,uBAAA,AAAuB,EACvD,WAAa,MAAM,AAAI,MAAM,sPAAwP,EACrR,uDACA,wJCLJ,EAAA,EAAA,CAAA,CAAA,KACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OCsBA,IAAM,EAAQ,AAAC,GAAe,IAAI,QAAQ,GAAW,WAAW,EAAS,IAGnE,EAA8B,CAClC,CAAE,GAAI,IAAK,KAAM,SAAU,YAAa,kBAAmB,SAAU,UAAW,EAChF,CAAE,GAAI,IAAK,KAAM,QAAS,YAAa,0BAA2B,SAAU,UAAW,EACvF,CAAE,GAAI,IAAK,KAAM,OAAQ,YAAa,qBAAsB,SAAU,QAAS,EAC/E,CAAE,GAAI,IAAK,KAAM,YAAa,YAAa,qBAAsB,SAAU,QAAS,EACpF,CAAE,GAAI,IAAK,KAAM,OAAQ,YAAa,gBAAiB,SAAU,MAAO,EACzE,CAEK,EAAiC,CACrC,CAAE,GAAI,UAAW,KAAM,UAAW,KAAM,UAAW,UAAU,CAAK,EAClE,CAAE,GAAI,UAAW,KAAM,UAAW,KAAM,UAAW,UAAU,CAAK,EAClE,CAAE,GAAI,WAAY,KAAM,WAAY,KAAM,WAAY,UAAU,CAAK,EACrE,CAAE,GAAI,SAAU,KAAM,kBAAmB,KAAM,SAAU,UAAU,CAAK,EACzE,CAEG,EAAoB,CACtB,CACE,GAAI,IACJ,KAAM,YACN,YAAa,oCACb,KAAM,OACN,UAAW,EACX,UAAU,EACV,UAAW,IAAI,KAAK,cACpB,UAAW,IAAI,KAAK,cACpB,MAAO,EAAE,CACT,kBAAmB,CACjB,CAAE,UAAW,UAAW,WAAW,CAAK,EACxC,CAAE,UAAW,UAAW,WAAW,CAAK,EACzC,CACD,YAAa,EAAE,CACf,OAAQ,CACN,CACE,GAAI,UACJ,KAAM,aACN,YAAa,wBACb,UAAW,EACX,SAAU,GACV,UAAW,IAAI,KAAK,cACpB,UAAW,IAAI,KAAK,cACpB,MAAO,EAAE,CACT,kBAAmB,EAAE,CACrB,OAAQ,IACR,MAAO,CACL,CACE,GAAI,SACJ,KAAM,gBACN,YAAa,qDACb,UAAW,MACX,UAAW,EACX,UAAU,EACV,aAAa,EACb,UAAW,IAAI,KAAK,cACpB,UAAW,IAAI,KAAK,cACpB,kBAAmB,EAAE,CACrB,KAAM,CAAC,QAAS,UAAU,CAC1B,UAAW,EAAE,CACb,oBAAqB,EAAE,CACvB,MAAO,EAAE,CACT,kBAAmB,EAAE,CACrB,eAAgB,CACd,CACE,GAAI,cACJ,KAAM,gBACN,YAAa,oBACb,YAAY,EACZ,cAAe,EACf,cAAe,EACf,UAAW,EACX,YAAa,QACb,UAAU,EACV,UAAW,IAAI,KAAK,cACpB,UAAW,IAAI,KAAK,cACpB,QAAS,CACP,CACE,GAAI,YACJ,KAAM,UACN,YAAa,wBACb,MAAO,EACP,UAAW,EACX,WAAW,EACX,UAAU,EACV,UAAW,IAAI,KAAK,cACpB,UAAW,IAAI,KAAK,cACpB,kBAAmB,EAAE,CACrB,UAAW,EAAE,CACb,MAAO,EACT,AADW,EAEX,CACE,GAAI,YACJ,KAAM,MACN,YAAa,4BACb,MAAO,EACP,UAAW,EACX,WAAW,EACX,UAAU,EACV,UAAW,IAAI,KAAK,cACpB,UAAW,IAAI,KAAK,cACpB,kBAAmB,EAAE,CACrB,UAAW,EAAE,CACb,MAAO,EAAE,AACX,EACD,AACH,EACD,AACH,EACD,CACD,UAAW,EAAE,AACf,EACD,AACH,EACD,CAIM,eAAe,EAAS,CAK9B,EACC,MAAM,EAAM,KAEZ,IAAI,EAAW,IAAI,EAAU,CAG7B,GAAI,GAAQ,OAAQ,CAClB,IAAM,EAAS,EAAO,MAAM,CAAC,WAAW,GACxC,EAAW,EAAS,MAAM,CAAC,GACzB,EAAK,IAAI,CAAC,WAAW,GAAG,QAAQ,CAAC,IACjC,EAAK,WAAW,EAAE,cAAc,SAAS,GAE7C,CAEI,GAAQ,gBAAa,IACvB,EAAW,EAAS,GADc,GACR,CAAC,GAAQ,EAAK,QAAQ,GAAK,EAAO,SAAQ,EAItE,IAAM,EAAO,GAAQ,MAAQ,EACvB,EAAQ,GAAQ,OAAS,GACzB,EAAQ,CAAC,GAAO,CAAC,CAAI,EAG3B,MAAO,CACL,KAAM,EAAS,KAAK,CAAC,EAHX,EAAQ,GAGU,AAC5B,MAAO,EAAS,MAAM,MACtB,QACA,CACF,CACF,CAuhBO,eAAe,IAEpB,OADA,MAAM,EAAM,IACL,IAAI,EAAe,AAC5B,CAEO,eAAe,IAEpB,OADA,MAAM,EAAM,IACL,IAAI,EAAgB,AAC7B,CD3sBe,eAAe,IAE5B,GAAM,CAAC,EAAa,EAAU,EAAU,CAAG,MAAM,QAAQ,GAAG,CAAC,CAC3D,EAAS,CAAE,KAAM,EAAG,MAAO,EAAG,GAC9B,IACA,IACD,EAED,MACE,CAAA,EAAA,EAAA,IAAA,EAAC,MAAA,CAAI,UAAU,kCACb,CAAA,EAAA,EAAA,GAAA,EAAC,EAAA,UAAU,CAAA,CACT,MAAM,kBACN,YAAY,mEAGd,CAAA,EAAA,EAAA,GAAA,EAAC,MAAA,CAAI,UAAU,gBACb,CAAA,EAAA,EAAA,GAAA,EAAC,EAAA,QAAQ,CAAA,CAAC,SAAU,CAAA,EAAA,EAAA,GAAA,EAAC,MAAA,UAAI,wCACvB,CAAA,EAAA,EAAA,GAAA,EAAC,EAAA,oBAAoB,CAAA,CACnB,aAAc,EAAY,IAAI,CAC9B,kBAAmB,EACnB,mBAAoB,UAMhC","ignoreList":[0,1,2,3,4,5,6,7,8,9]}