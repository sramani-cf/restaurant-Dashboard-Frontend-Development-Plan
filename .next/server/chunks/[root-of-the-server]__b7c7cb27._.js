module.exports=[66680,(e,t,r)=>{t.exports=e.x("node:crypto",()=>require("node:crypto"))},12057,(e,t,r)=>{t.exports=e.x("node:util",()=>require("node:util"))},47299,(e,t,r)=>{t.exports=e.x("node:http",()=>require("node:http"))},43698,(e,t,r)=>{t.exports=e.x("node:https",()=>require("node:https"))},87769,(e,t,r)=>{t.exports=e.x("node:events",()=>require("node:events"))},85199,e=>{"use strict";let t,r;e.s(["CompactEncrypt",()=>to,"CompactSign",()=>tc,"EmbeddedJWK",()=>tE,"EncryptJWT",()=>ty,"FlattenedEncrypt",()=>eX,"FlattenedSign",()=>ts,"GeneralEncrypt",()=>eY,"GeneralSign",()=>tp,"SignJWT",()=>tu,"UnsecuredJWT",()=>tC,"base64url",()=>tB,"calculateJwkThumbprint",()=>tw,"calculateJwkThumbprintUri",()=>tm,"compactDecrypt",()=>e$,"compactVerify",()=>e3,"createLocalJWKSet",()=>tA,"createRemoteJWKSet",()=>tJ,"cryptoRuntime",()=>tG,"decodeJwt",()=>tx,"decodeProtectedHeader",()=>tO,"errors",()=>tU,"experimental_jwksCache",()=>tT,"exportJWK",()=>eV,"exportPKCS8",()=>eF,"exportSPKI",()=>eL,"flattenedDecrypt",()=>eN,"flattenedVerify",()=>e6,"generalDecrypt",()=>eB,"generalVerify",()=>e9,"generateKeyPair",()=>tN,"generateSecret",()=>t$,"importJWK",()=>eW,"importPKCS8",()=>eK,"importSPKI",()=>ek,"importX509",()=>eP,"jwksCache",()=>tK,"jwtDecrypt",()=>tn,"jwtVerify",()=>ti],85199),e.s([],82227),e.i(82227);var a=e.i(51615),i=e.i(66680);let n=(e,t)=>(0,i.createHash)(e).update(t).digest(),o=new TextEncoder,s=new TextDecoder;function c(...e){let t=new Uint8Array(e.reduce((e,{length:t})=>e+t,0)),r=0;for(let a of e)t.set(a,r),r+=a.length;return t}function d(e,t){return c(o.encode(e),new Uint8Array([0]),t)}function p(e,t,r){if(t<0||t>=0x100000000)throw RangeError(`value must be >= 0 and <= ${0x100000000-1}. Received ${t}`);e.set([t>>>24,t>>>16,t>>>8,255&t],r)}function l(e){let t=new Uint8Array(4);return p(t,e),t}function h(e){return c(l(e.length),e)}async function u(e,t,r){let a=Math.ceil((t>>3)/32),i=new Uint8Array(32*a);for(let t=0;t<a;t++){let a=new Uint8Array(4+e.length+r.length);a.set(l(t+1)),a.set(e,4),a.set(r,4+e.length),i.set(await n("sha256",a),32*t)}return i.slice(0,t>>3)}let y=e=>a.Buffer.from(e).toString("base64url"),f=e=>new Uint8Array(a.Buffer.from(function(e){let t=e;return t instanceof Uint8Array&&(t=s.decode(t)),t}(e),"base64url"));e.s(["JOSEAlgNotAllowed",()=>g,"JOSEError",()=>w,"JOSENotSupported",()=>S,"JWEDecryptionFailed",()=>_,"JWEInvalid",()=>b,"JWKInvalid",()=>H,"JWKSInvalid",()=>k,"JWKSMultipleMatchingKeys",()=>K,"JWKSNoMatchingKey",()=>P,"JWKSTimeout",()=>W,"JWSInvalid",()=>A,"JWSSignatureVerificationFailed",()=>J,"JWTClaimValidationFailed",()=>m,"JWTExpired",()=>E,"JWTInvalid",()=>v],1842);class w extends Error{static code="ERR_JOSE_GENERIC";code="ERR_JOSE_GENERIC";constructor(e,t){super(e,t),this.name=this.constructor.name,Error.captureStackTrace?.(this,this.constructor)}}class m extends w{static code="ERR_JWT_CLAIM_VALIDATION_FAILED";code="ERR_JWT_CLAIM_VALIDATION_FAILED";claim;reason;payload;constructor(e,t,r="unspecified",a="unspecified"){super(e,{cause:{claim:r,reason:a,payload:t}}),this.claim=r,this.reason=a,this.payload=t}}class E extends w{static code="ERR_JWT_EXPIRED";code="ERR_JWT_EXPIRED";claim;reason;payload;constructor(e,t,r="unspecified",a="unspecified"){super(e,{cause:{claim:r,reason:a,payload:t}}),this.claim=r,this.reason=a,this.payload=t}}class g extends w{static code="ERR_JOSE_ALG_NOT_ALLOWED";code="ERR_JOSE_ALG_NOT_ALLOWED"}class S extends w{static code="ERR_JOSE_NOT_SUPPORTED";code="ERR_JOSE_NOT_SUPPORTED"}class _ extends w{static code="ERR_JWE_DECRYPTION_FAILED";code="ERR_JWE_DECRYPTION_FAILED";constructor(e="decryption operation failed",t){super(e,t)}}class b extends w{static code="ERR_JWE_INVALID";code="ERR_JWE_INVALID"}class A extends w{static code="ERR_JWS_INVALID";code="ERR_JWS_INVALID"}class v extends w{static code="ERR_JWT_INVALID";code="ERR_JWT_INVALID"}class H extends w{static code="ERR_JWK_INVALID";code="ERR_JWK_INVALID"}class k extends w{static code="ERR_JWKS_INVALID";code="ERR_JWKS_INVALID"}class P extends w{static code="ERR_JWKS_NO_MATCHING_KEY";code="ERR_JWKS_NO_MATCHING_KEY";constructor(e="no applicable key found in the JSON Web Key Set",t){super(e,t)}}class K extends w{[Symbol.asyncIterator];static code="ERR_JWKS_MULTIPLE_MATCHING_KEYS";code="ERR_JWKS_MULTIPLE_MATCHING_KEYS";constructor(e="multiple matching keys found in the JSON Web Key Set",t){super(e,t)}}class W extends w{static code="ERR_JWKS_TIMEOUT";code="ERR_JWKS_TIMEOUT";constructor(e="request timed out",t){super(e,t)}}class J extends w{static code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED";code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED";constructor(e="signature verification failed",t){super(e,t)}}var T=i;function C(e){switch(e){case"A128GCM":case"A128GCMKW":case"A192GCM":case"A192GCMKW":case"A256GCM":case"A256GCMKW":return 96;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return 128;default:throw new S(`Unsupported JWE Algorithm: ${e}`)}}let I=(e,t)=>{if(t.length<<3!==C(e))throw new b("Invalid Initialization Vector length")};var R=e.i(12057);let O=e=>R.types.isKeyObject(e),x=(e,t)=>{let r;switch(e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":r=parseInt(e.slice(-3),10);break;case"A128GCM":case"A192GCM":case"A256GCM":r=parseInt(e.slice(1,4),10);break;default:throw new S(`Content Encryption Algorithm ${e} is not supported either by JOSE or your javascript runtime`)}if(t instanceof Uint8Array){let e=t.byteLength<<3;if(e!==r)throw new b(`Invalid Content Encryption Key length. Expected ${r} bits, got ${e} bits`);return}if(O(t)&&"secret"===t.type){let e=t.symmetricKeySize<<3;if(e!==r)throw new b(`Invalid Content Encryption Key length. Expected ${r} bits, got ${e} bits`);return}throw TypeError("Invalid Content Encryption Key type")},U=i.timingSafeEqual;function D(e,t,r,a,n,o){let s=c(e,t,r,function(e){let t=Math.floor(e/0x100000000),r=new Uint8Array(8);return p(r,t,0),p(r,e%0x100000000,4),r}(e.length<<3)),d=(0,i.createHmac)(`sha${a}`,n);return d.update(s),d.digest().slice(0,o>>3)}let j=i.webcrypto,M=e=>R.types.isCryptoKey(e);function N(e,t="algorithm.name"){return TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function $(e,t){return e.name===t}function B(e){return parseInt(e.name.slice(4),10)}function G(e,t){if(t.length&&!t.some(t=>e.usages.includes(t))){let e="CryptoKey does not support this operation, its usages must include ";if(t.length>2){let r=t.pop();e+=`one of ${t.join(", ")}, or ${r}.`}else 2===t.length?e+=`one of ${t[0]} or ${t[1]}.`:e+=`${t[0]}.`;throw TypeError(e)}}function L(e,t,...r){switch(t){case"A128GCM":case"A192GCM":case"A256GCM":{if(!$(e.algorithm,"AES-GCM"))throw N("AES-GCM");let r=parseInt(t.slice(1,4),10);if(e.algorithm.length!==r)throw N(r,"algorithm.length");break}case"A128KW":case"A192KW":case"A256KW":{if(!$(e.algorithm,"AES-KW"))throw N("AES-KW");let r=parseInt(t.slice(1,4),10);if(e.algorithm.length!==r)throw N(r,"algorithm.length");break}case"ECDH":switch(e.algorithm.name){case"ECDH":case"X25519":case"X448":break;default:throw N("ECDH, X25519, or X448")}break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(!$(e.algorithm,"PBKDF2"))throw N("PBKDF2");break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(!$(e.algorithm,"RSA-OAEP"))throw N("RSA-OAEP");let r=parseInt(t.slice(9),10)||1;if(B(e.algorithm.hash)!==r)throw N(`SHA-${r}`,"algorithm.hash");break}default:throw TypeError("CryptoKey does not support this operation")}G(e,r)}function F(e,t,...r){if((r=r.filter(Boolean)).length>2){let t=r.pop();e+=`one of type ${r.join(", ")}, or ${t}.`}else 2===r.length?e+=`one of type ${r[0]} or ${r[1]}.`:e+=`of type ${r[0]}.`;return null==t?e+=` Received ${t}`:"function"==typeof t&&t.name?e+=` Received function ${t.name}`:"object"==typeof t&&null!=t&&t.constructor?.name&&(e+=` Received an instance of ${t.constructor.name}`),e}let V=(e,...t)=>F("Key must be ",e,...t);function z(e,t,...r){return F(`Key for the ${e} algorithm must be `,t,...r)}let X=e=>(t||=new Set((0,i.getCiphers)())).has(e),q=e=>O(e)||M(e),Y=["KeyObject"];(globalThis.CryptoKey||j?.CryptoKey)&&Y.push("CryptoKey");let Q=(e,t,r,a,n,o)=>{let s;if(M(t))L(t,e,"decrypt"),s=i.KeyObject.from(t);else if(t instanceof Uint8Array||O(t))s=t;else throw TypeError(V(t,...Y,"Uint8Array"));if(!a)throw new b("JWE Initialization Vector missing");if(!n)throw new b("JWE Authentication Tag missing");switch(x(e,s),I(e,a),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return function(e,t,r,a,n,o){let s,d,p=parseInt(e.slice(1,4),10);O(t)&&(t=t.export());let l=t.subarray(p>>3),h=t.subarray(0,p>>3),u=parseInt(e.slice(-3),10),y=`aes-${p}-cbc`;if(!X(y))throw new S(`alg ${e} is not supported by your javascript runtime`);let f=D(o,a,r,u,h,p);try{s=U(n,f)}catch{}if(!s)throw new _;try{let e=(0,i.createDecipheriv)(y,l,a);d=c(e.update(r),e.final())}catch{}if(!d)throw new _;return d}(e,s,r,a,n,o);case"A128GCM":case"A192GCM":case"A256GCM":return function(e,t,r,a,n,o){let s=parseInt(e.slice(1,4),10),c=`aes-${s}-gcm`;if(!X(c))throw new S(`alg ${e} is not supported by your javascript runtime`);try{let e=(0,i.createDecipheriv)(c,t,a,{authTagLength:16});e.setAuthTag(n),o.byteLength&&e.setAAD(o,{plaintextLength:r.length});let s=e.update(r);return e.final(),s}catch{throw new _}}(e,s,r,a,n,o);default:throw new S("Unsupported JWE Content Encryption Algorithm")}},Z=(...e)=>{let t,r=e.filter(Boolean);if(0===r.length||1===r.length)return!0;for(let e of r){let r=Object.keys(e);if(!t||0===t.size){t=new Set(r);continue}for(let e of r){if(t.has(e))return!1;t.add(e)}}return!0};function ee(e){if("object"!=typeof e||null===e||"[object Object]"!==Object.prototype.toString.call(e))return!1;if(null===Object.getPrototypeOf(e))return!0;let t=e;for(;null!==Object.getPrototypeOf(t);)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t}function et(e,t){if(e.symmetricKeySize<<3!==parseInt(t.slice(1,4),10))throw TypeError(`Invalid key size for alg: ${t}`)}function er(e,t,r){if(O(e))return e;if(e instanceof Uint8Array)return(0,i.createSecretKey)(e);if(M(e))return L(e,t,r),i.KeyObject.from(e);throw TypeError(V(e,...Y,"Uint8Array"))}let ea=(e,t,r)=>{let n=parseInt(e.slice(1,4),10),o=`aes${n}-wrap`;if(!X(o))throw new S(`alg ${e} is not supported either by JOSE or your javascript runtime`);let s=er(t,e,"wrapKey");et(s,e);let d=(0,i.createCipheriv)(o,s,a.Buffer.alloc(8,166));return c(d.update(r),d.final())},ei=(e,t,r)=>{let n=parseInt(e.slice(1,4),10),o=`aes${n}-wrap`;if(!X(o))throw new S(`alg ${e} is not supported either by JOSE or your javascript runtime`);let s=er(t,e,"unwrapKey");et(s,e);let d=(0,i.createDecipheriv)(o,s,a.Buffer.alloc(8,166));return c(d.update(r),d.final())};function en(e){return ee(e)&&"string"==typeof e.kty}new WeakMap;let eo=(e,t)=>{let r;if(M(e))r=i.KeyObject.from(e);else if(O(e))r=e;else if(en(e))return e.crv;else throw TypeError(V(e,...Y));if("secret"===r.type)throw TypeError('only "private" or "public" type keys can be used for this operation');switch(r.asymmetricKeyType){case"ed25519":case"ed448":return`Ed${r.asymmetricKeyType.slice(2)}`;case"x25519":case"x448":return`X${r.asymmetricKeyType.slice(1)}`;case"ec":{let e=r.asymmetricKeyDetails.namedCurve;if(t)return e;switch(e){case"prime256v1":return"P-256";case"secp384r1":return"P-384";case"secp521r1":return"P-521";case"secp256k1":return"secp256k1";default:throw new S("Unsupported key curve for this operation")}}default:throw TypeError("Invalid asymmetric key type for this operation")}},es=(0,R.promisify)(i.generateKeyPair);async function ec(e,t,r,a,n=new Uint8Array(0),s=new Uint8Array(0)){let d,p;if(M(e))L(e,"ECDH"),d=i.KeyObject.from(e);else if(O(e))d=e;else throw TypeError(V(e,...Y));if(M(t))L(t,"ECDH","deriveBits"),p=i.KeyObject.from(t);else if(O(t))p=t;else throw TypeError(V(t,...Y));let y=c(h(o.encode(r)),h(n),h(s),l(a));return u((0,i.diffieHellman)({privateKey:p,publicKey:d}),a,y)}async function ed(e){let t;if(M(e))t=i.KeyObject.from(e);else if(O(e))t=e;else throw TypeError(V(e,...Y));switch(t.asymmetricKeyType){case"x25519":return es("x25519");case"x448":return es("x448");case"ec":return es("ec",{namedCurve:eo(t)});default:throw new S("Invalid or unsupported EPK")}}let ep=e=>["P-256","P-384","P-521","X25519","X448"].includes(eo(e));var T=i;function el(e){if(!(e instanceof Uint8Array)||e.length<8)throw new b("PBES2 Salt Input must be 8 or more octets")}let eh=(0,R.promisify)(i.pbkdf2);function eu(e,t){if(O(e))return e.export();if(e instanceof Uint8Array)return e;if(M(e))return L(e,t,"deriveBits","deriveKey"),i.KeyObject.from(e).export();throw TypeError(V(e,...Y,"Uint8Array"))}let ey=async(e,t,r,a=2048,i=(0,T.randomFillSync)(new Uint8Array(16)))=>{el(i);let n=d(e,i),o=parseInt(e.slice(13,16),10)>>3,s=eu(t,e),c=await eh(s,n,a,o,`sha${e.slice(8,11)}`);return{encryptedKey:await ea(e.slice(-6),c,r),p2c:a,p2s:y(i)}},ef=async(e,t,r,a,i)=>{el(i);let n=d(e,i),o=parseInt(e.slice(13,16),10)>>3,s=eu(t,e),c=await eh(s,n,a,o,`sha${e.slice(8,11)}`);return ei(e.slice(-6),c,r)},ew=(e,t)=>{let r;try{r=e instanceof i.KeyObject?e.asymmetricKeyDetails?.modulusLength:Buffer.from(e.n,"base64url").byteLength<<3}catch{}if("number"!=typeof r||r<2048)throw TypeError(`${t} requires key modulusLength to be 2048 bits or larger`)},em=(e,t)=>{if("rsa"!==e.asymmetricKeyType)throw TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa");ew(e,t)},eE=(0,R.deprecate)(()=>i.constants.RSA_PKCS1_PADDING,'The RSA1_5 "alg" (JWE Algorithm) is deprecated and will be removed in the next major revision.'),eg=e=>{switch(e){case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":return i.constants.RSA_PKCS1_OAEP_PADDING;case"RSA1_5":return eE();default:return}},eS=e=>{switch(e){case"RSA-OAEP":return"sha1";case"RSA-OAEP-256":return"sha256";case"RSA-OAEP-384":return"sha384";case"RSA-OAEP-512":return"sha512";default:return}};function e_(e,t,...r){if(O(e))return e;if(M(e))return L(e,t,...r),i.KeyObject.from(e);throw TypeError(V(e,...Y))}let eb={};var T=i;function eA(e){switch(e){case"A128GCM":return 128;case"A192GCM":return 192;case"A256GCM":case"A128CBC-HS256":return 256;case"A192CBC-HS384":return 384;case"A256CBC-HS512":return 512;default:throw new S(`Unsupported JWE Algorithm: ${e}`)}}let ev=e=>(0,T.randomFillSync)(new Uint8Array(eA(e)>>3)),eH=(e,t,r)=>{let a;if(M(r)){if(!r.extractable)throw TypeError("CryptoKey is not extractable");a=i.KeyObject.from(r)}else if(O(r))a=r;else throw TypeError(V(r,...Y));if(a.type!==e)throw TypeError(`key is not a ${e} key`);return a.export({format:"pem",type:t})};async function ek(e,t,r){if("string"!=typeof e||0!==e.indexOf("-----BEGIN PUBLIC KEY-----"))throw TypeError('"spki" must be SPKI formatted string');return(0,i.createPublicKey)({key:a.Buffer.from(e.replace(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g,""),"base64"),type:"spki",format:"der"})}async function eP(e,t,r){if("string"!=typeof e||0!==e.indexOf("-----BEGIN CERTIFICATE-----"))throw TypeError('"x509" must be X.509 formatted string');return(0,i.createPublicKey)({key:e,type:"spki",format:"pem"})}async function eK(e,t,r){if("string"!=typeof e||0!==e.indexOf("-----BEGIN PRIVATE KEY-----"))throw TypeError('"pkcs8" must be PKCS#8 formatted string');return(0,i.createPrivateKey)({key:a.Buffer.from(e.replace(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g,""),"base64"),type:"pkcs8",format:"der"})}async function eW(e,t){if(!ee(e))throw TypeError("JWK must be an object");switch(t||=e.alg,e.kty){case"oct":if("string"!=typeof e.k||!e.k)throw TypeError('missing "k" (Key Value) Parameter value');return f(e.k);case"RSA":if("oth"in e&&void 0!==e.oth)throw new S('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":var r;return(r={...e,alg:t}).d?(0,i.createPrivateKey)({format:"jwk",key:r}):(0,i.createPublicKey)({format:"jwk",key:r});default:throw new S('Unsupported "kty" (Key Type) Parameter value')}}let eJ=e=>e?.[Symbol.toStringTag],eT=(e,t,r)=>{if(void 0!==t.use&&"sig"!==t.use)throw TypeError("Invalid key for this operation, when present its use must be sig");if(void 0!==t.key_ops&&t.key_ops.includes?.(r)!==!0)throw TypeError(`Invalid key for this operation, when present its key_ops must include ${r}`);if(void 0!==t.alg&&t.alg!==e)throw TypeError(`Invalid key for this operation, when present its alg must be ${e}`);return!0};function eC(e,t,r,a){t.startsWith("HS")||"dir"===t||t.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(t)?((e,t,r,a)=>{if(!(t instanceof Uint8Array)){if(a&&en(t)){var i;if(en(i=t)&&"oct"===i.kty&&"string"==typeof i.k&&eT(e,t,r))return;throw TypeError('JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present')}if(!q(t))throw TypeError(z(e,t,...Y,"Uint8Array",a?"JSON Web Key":null));if("secret"!==t.type)throw TypeError(`${eJ(t)} instances for symmetric algorithms must be of type "secret"`)}})(t,r,a,e):((e,t,r,a)=>{var i,n;if(a&&en(t))switch(r){case"sign":if("oct"!==(i=t).kty&&"string"==typeof i.d&&eT(e,t,r))return;throw TypeError("JSON Web Key for this operation be a private JWK");case"verify":if("oct"!==(n=t).kty&&void 0===n.d&&eT(e,t,r))return;throw TypeError("JSON Web Key for this operation be a public JWK")}if(!q(t))throw TypeError(z(e,t,...Y,a?"JSON Web Key":null));if("secret"===t.type)throw TypeError(`${eJ(t)} instances for asymmetric algorithms must not be of type "secret"`);if("sign"===r&&"public"===t.type)throw TypeError(`${eJ(t)} instances for asymmetric algorithm signing must be of type "private"`);if("decrypt"===r&&"public"===t.type)throw TypeError(`${eJ(t)} instances for asymmetric algorithm decryption must be of type "private"`);if(t.algorithm&&"verify"===r&&"private"===t.type)throw TypeError(`${eJ(t)} instances for asymmetric algorithm verifying must be of type "public"`);if(t.algorithm&&"encrypt"===r&&"private"===t.type)throw TypeError(`${eJ(t)} instances for asymmetric algorithm encryption must be of type "public"`)})(t,r,a,e)}let eI=eC.bind(void 0,!1),eR=eC.bind(void 0,!0),eO=(e,t,r,a,n)=>{let o;if(M(r))L(r,e,"encrypt"),o=i.KeyObject.from(r);else if(r instanceof Uint8Array||O(r))o=r;else throw TypeError(V(r,...Y,"Uint8Array"));if(x(e,o),a)I(e,a);else a=(0,T.randomFillSync)(new Uint8Array(C(e)>>3));switch(e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return function(e,t,r,a,n){let o=parseInt(e.slice(1,4),10);O(r)&&(r=r.export());let s=r.subarray(o>>3),d=r.subarray(0,o>>3),p=`aes-${o}-cbc`;if(!X(p))throw new S(`alg ${e} is not supported by your javascript runtime`);let l=(0,i.createCipheriv)(p,s,a),h=c(l.update(t),l.final()),u=D(n,a,h,parseInt(e.slice(-3),10),d,o);return{ciphertext:h,tag:u,iv:a}}(e,t,o,a,n);case"A128GCM":case"A192GCM":case"A256GCM":return function(e,t,r,a,n){let o=parseInt(e.slice(1,4),10),s=`aes-${o}-gcm`;if(!X(s))throw new S(`alg ${e} is not supported by your javascript runtime`);let c=(0,i.createCipheriv)(s,r,a,{authTagLength:16});n.byteLength&&c.setAAD(n,{plaintextLength:t.length});let d=c.update(t);return c.final(),{ciphertext:d,tag:c.getAuthTag(),iv:a}}(e,t,o,a,n);default:throw new S("Unsupported JWE Content Encryption Algorithm")}};async function ex(e,t,r,a){let i=e.slice(0,7),n=await eO(i,r,t,a,new Uint8Array(0));return{encryptedKey:n.ciphertext,iv:y(n.iv),tag:y(n.tag)}}async function eU(e,t,r,a,i){return Q(e.slice(0,7),t,r,a,i,new Uint8Array(0))}async function eD(e,t,r,a,n){switch(eI(e,t,"decrypt"),t=await eb.normalizePrivateKey?.(t,e)||t,e){case"dir":if(void 0!==r)throw new b("Encountered unexpected JWE Encrypted Key");return t;case"ECDH-ES":if(void 0!==r)throw new b("Encountered unexpected JWE Encrypted Key");case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{let i,n;if(!ee(a.epk))throw new b('JOSE Header "epk" (Ephemeral Public Key) missing or invalid');if(!ep(t))throw new S("ECDH with the provided key is not allowed or not supported by your javascript runtime");let o=await eW(a.epk,e);if(void 0!==a.apu){if("string"!=typeof a.apu)throw new b('JOSE Header "apu" (Agreement PartyUInfo) invalid');try{i=f(a.apu)}catch{throw new b("Failed to base64url decode the apu")}}if(void 0!==a.apv){if("string"!=typeof a.apv)throw new b('JOSE Header "apv" (Agreement PartyVInfo) invalid');try{n=f(a.apv)}catch{throw new b("Failed to base64url decode the apv")}}let s=await ec(o,t,"ECDH-ES"===e?a.enc:e,"ECDH-ES"===e?eA(a.enc):parseInt(e.slice(-5,-2),10),i,n);if("ECDH-ES"===e)return s;if(void 0===r)throw new b("JWE Encrypted Key missing");return ei(e.slice(-6),s,r)}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":if(void 0===r)throw new b("JWE Encrypted Key missing");var o=t;let s=eg(e),c=eS(e),d=e_(o,e,"unwrapKey","decrypt");return em(d,e),(0,i.privateDecrypt)({key:d,oaepHash:c,padding:s},r);case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{let i;if(void 0===r)throw new b("JWE Encrypted Key missing");if("number"!=typeof a.p2c)throw new b('JOSE Header "p2c" (PBES2 Count) missing or invalid');let o=n?.maxPBES2Count||1e4;if(a.p2c>o)throw new b('JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds');if("string"!=typeof a.p2s)throw new b('JOSE Header "p2s" (PBES2 Salt) missing or invalid');try{i=f(a.p2s)}catch{throw new b("Failed to base64url decode the p2s")}return ef(e,t,r,a.p2c,i)}case"A128KW":case"A192KW":case"A256KW":if(void 0===r)throw new b("JWE Encrypted Key missing");return ei(e,t,r);case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{let i,n;if(void 0===r)throw new b("JWE Encrypted Key missing");if("string"!=typeof a.iv)throw new b('JOSE Header "iv" (Initialization Vector) missing or invalid');if("string"!=typeof a.tag)throw new b('JOSE Header "tag" (Authentication Tag) missing or invalid');try{i=f(a.iv)}catch{throw new b("Failed to base64url decode the iv")}try{n=f(a.tag)}catch{throw new b("Failed to base64url decode the tag")}return eU(e,t,r,i,n)}default:throw new S('Invalid or unsupported "alg" (JWE Algorithm) header value')}}let ej=function(e,t,r,a,i){let n;if(void 0!==i.crit&&a?.crit===void 0)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!a||void 0===a.crit)return new Set;if(!Array.isArray(a.crit)||0===a.crit.length||a.crit.some(e=>"string"!=typeof e||0===e.length))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');for(let o of(n=void 0!==r?new Map([...Object.entries(r),...t.entries()]):t,a.crit)){if(!n.has(o))throw new S(`Extension Header Parameter "${o}" is not recognized`);if(void 0===i[o])throw new e(`Extension Header Parameter "${o}" is missing`);if(n.get(o)&&void 0===a[o])throw new e(`Extension Header Parameter "${o}" MUST be integrity protected`)}return new Set(a.crit)},eM=(e,t)=>{if(void 0!==t&&(!Array.isArray(t)||t.some(e=>"string"!=typeof e)))throw TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)};async function eN(e,t,r){let a,i,n,d,p,l,h;if(!ee(e))throw new b("Flattened JWE must be an object");if(void 0===e.protected&&void 0===e.header&&void 0===e.unprotected)throw new b("JOSE Header missing");if(void 0!==e.iv&&"string"!=typeof e.iv)throw new b("JWE Initialization Vector incorrect type");if("string"!=typeof e.ciphertext)throw new b("JWE Ciphertext missing or incorrect type");if(void 0!==e.tag&&"string"!=typeof e.tag)throw new b("JWE Authentication Tag incorrect type");if(void 0!==e.protected&&"string"!=typeof e.protected)throw new b("JWE Protected Header incorrect type");if(void 0!==e.encrypted_key&&"string"!=typeof e.encrypted_key)throw new b("JWE Encrypted Key incorrect type");if(void 0!==e.aad&&"string"!=typeof e.aad)throw new b("JWE AAD incorrect type");if(void 0!==e.header&&!ee(e.header))throw new b("JWE Shared Unprotected Header incorrect type");if(void 0!==e.unprotected&&!ee(e.unprotected))throw new b("JWE Per-Recipient Unprotected Header incorrect type");if(e.protected)try{let t=f(e.protected);a=JSON.parse(s.decode(t))}catch{throw new b("JWE Protected Header is invalid")}if(!Z(a,e.header,e.unprotected))throw new b("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");let u={...a,...e.header,...e.unprotected};if(ej(b,new Map,r?.crit,a,u),void 0!==u.zip)throw new S('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');let{alg:y,enc:w}=u;if("string"!=typeof y||!y)throw new b("missing JWE Algorithm (alg) in JWE Header");if("string"!=typeof w||!w)throw new b("missing JWE Encryption Algorithm (enc) in JWE Header");let m=r&&eM("keyManagementAlgorithms",r.keyManagementAlgorithms),E=r&&eM("contentEncryptionAlgorithms",r.contentEncryptionAlgorithms);if(m&&!m.has(y)||!m&&y.startsWith("PBES2"))throw new g('"alg" (Algorithm) Header Parameter value not allowed');if(E&&!E.has(w))throw new g('"enc" (Encryption Algorithm) Header Parameter value not allowed');if(void 0!==e.encrypted_key)try{i=f(e.encrypted_key)}catch{throw new b("Failed to base64url decode the encrypted_key")}let _=!1;"function"==typeof t&&(t=await t(a,e),_=!0);try{n=await eD(y,t,i,u,r)}catch(e){if(e instanceof TypeError||e instanceof b||e instanceof S)throw e;n=ev(w)}if(void 0!==e.iv)try{d=f(e.iv)}catch{throw new b("Failed to base64url decode the iv")}if(void 0!==e.tag)try{p=f(e.tag)}catch{throw new b("Failed to base64url decode the tag")}let A=o.encode(e.protected??"");l=void 0!==e.aad?c(A,o.encode("."),o.encode(e.aad)):A;try{h=f(e.ciphertext)}catch{throw new b("Failed to base64url decode the ciphertext")}let v={plaintext:await Q(w,n,h,d,p,l)};if(void 0!==e.protected&&(v.protectedHeader=a),void 0!==e.aad)try{v.additionalAuthenticatedData=f(e.aad)}catch{throw new b("Failed to base64url decode the aad")}return(void 0!==e.unprotected&&(v.sharedUnprotectedHeader=e.unprotected),void 0!==e.header&&(v.unprotectedHeader=e.header),_)?{...v,key:t}:v}async function e$(e,t,r){if(e instanceof Uint8Array&&(e=s.decode(e)),"string"!=typeof e)throw new b("Compact JWE must be a string or Uint8Array");let{0:a,1:i,2:n,3:o,4:c,length:d}=e.split(".");if(5!==d)throw new b("Invalid Compact JWE");let p=await eN({ciphertext:o,iv:n||void 0,protected:a,tag:c||void 0,encrypted_key:i||void 0},t,r),l={plaintext:p.plaintext,protectedHeader:p.protectedHeader};return"function"==typeof t?{...l,key:p.key}:l}async function eB(e,t,r){if(!ee(e))throw new b("General JWE must be an object");if(!Array.isArray(e.recipients)||!e.recipients.every(ee))throw new b("JWE Recipients missing or incorrect type");if(!e.recipients.length)throw new b("JWE Recipients has no members");for(let a of e.recipients)try{return await eN({aad:e.aad,ciphertext:e.ciphertext,encrypted_key:a.encrypted_key,header:a.header,iv:e.iv,protected:e.protected,tag:e.tag,unprotected:e.unprotected},t,r)}catch{}throw new _}let eG=Symbol();async function eL(e){return eH("public","spki",e)}async function eF(e){return eH("private","pkcs8",e)}async function eV(e){let t;if(M(e)){if(!e.extractable)throw TypeError("CryptoKey is not extractable");t=i.KeyObject.from(e)}else if(O(e))t=e;else if(e instanceof Uint8Array)return{kty:"oct",k:y(e)};else throw TypeError(V(e,...Y,"Uint8Array"));if("secret"!==t.type&&!["rsa","ec","ed25519","x25519","ed448","x448"].includes(t.asymmetricKeyType))throw new S("Unsupported key asymmetricKeyType");return t.export({format:"jwk"})}async function ez(e,t,r,a,n={}){let o,s,c;switch(eI(e,r,"encrypt"),r=await eb.normalizePublicKey?.(r,e)||r,e){case"dir":c=r;break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!ep(r))throw new S("ECDH with the provided key is not allowed or not supported by your javascript runtime");let{apu:i,apv:d}=n,{epk:p}=n;p||=(await ed(r)).privateKey;let{x:l,y:h,crv:u,kty:f}=await eV(p),w=await ec(r,p,"ECDH-ES"===e?t:e,"ECDH-ES"===e?eA(t):parseInt(e.slice(-5,-2),10),i,d);if(s={epk:{x:l,crv:u,kty:f}},"EC"===f&&(s.epk.y=h),i&&(s.apu=y(i)),d&&(s.apv=y(d)),"ECDH-ES"===e){c=w;break}c=a||ev(t);let m=e.slice(-6);o=await ea(m,w,c);break}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":c=a||ev(t),o=await ((e,t,r)=>{let a=eg(e),n=eS(e),o=e_(t,e,"wrapKey","encrypt");return em(o,e),(0,i.publicEncrypt)({key:o,oaepHash:n,padding:a},r)})(e,r,c);break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{c=a||ev(t);let{p2c:i,p2s:d}=n;({encryptedKey:o,...s}=await ey(e,r,c,i,d));break}case"A128KW":case"A192KW":case"A256KW":c=a||ev(t),o=await ea(e,r,c);break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{c=a||ev(t);let{iv:i}=n;({encryptedKey:o,...s}=await ex(e,r,c,i));break}default:throw new S('Invalid or unsupported "alg" (JWE Algorithm) header value')}return{cek:c,encryptedKey:o,parameters:s}}class eX{_plaintext;_protectedHeader;_sharedUnprotectedHeader;_unprotectedHeader;_aad;_cek;_iv;_keyManagementParameters;constructor(e){if(!(e instanceof Uint8Array))throw TypeError("plaintext must be an instance of Uint8Array");this._plaintext=e}setKeyManagementParameters(e){if(this._keyManagementParameters)throw TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=e,this}setProtectedHeader(e){if(this._protectedHeader)throw TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setSharedUnprotectedHeader(e){if(this._sharedUnprotectedHeader)throw TypeError("setSharedUnprotectedHeader can only be called once");return this._sharedUnprotectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}setAdditionalAuthenticatedData(e){return this._aad=e,this}setContentEncryptionKey(e){if(this._cek)throw TypeError("setContentEncryptionKey can only be called once");return this._cek=e,this}setInitializationVector(e){if(this._iv)throw TypeError("setInitializationVector can only be called once");return this._iv=e,this}async encrypt(e,t){let r,a,i,n,d;if(!this._protectedHeader&&!this._unprotectedHeader&&!this._sharedUnprotectedHeader)throw new b("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");if(!Z(this._protectedHeader,this._unprotectedHeader,this._sharedUnprotectedHeader))throw new b("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");let p={...this._protectedHeader,...this._unprotectedHeader,...this._sharedUnprotectedHeader};if(ej(b,new Map,t?.crit,this._protectedHeader,p),void 0!==p.zip)throw new S('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');let{alg:l,enc:h}=p;if("string"!=typeof l||!l)throw new b('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("string"!=typeof h||!h)throw new b('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');if(this._cek&&("dir"===l||"ECDH-ES"===l))throw TypeError(`setContentEncryptionKey cannot be called with JWE "alg" (Algorithm) Header ${l}`);{let i;({cek:a,encryptedKey:r,parameters:i}=await ez(l,h,e,this._cek,this._keyManagementParameters)),i&&(t&&eG in t?this._unprotectedHeader?this._unprotectedHeader={...this._unprotectedHeader,...i}:this.setUnprotectedHeader(i):this._protectedHeader?this._protectedHeader={...this._protectedHeader,...i}:this.setProtectedHeader(i))}n=this._protectedHeader?o.encode(y(JSON.stringify(this._protectedHeader))):o.encode(""),this._aad?(d=y(this._aad),i=c(n,o.encode("."),o.encode(d))):i=n;let{ciphertext:u,tag:f,iv:w}=await eO(h,this._plaintext,a,this._iv,i),m={ciphertext:y(u)};return w&&(m.iv=y(w)),f&&(m.tag=y(f)),r&&(m.encrypted_key=y(r)),d&&(m.aad=d),this._protectedHeader&&(m.protected=s.decode(n)),this._sharedUnprotectedHeader&&(m.unprotected=this._sharedUnprotectedHeader),this._unprotectedHeader&&(m.header=this._unprotectedHeader),m}}class eq{parent;unprotectedHeader;key;options;constructor(e,t,r){this.parent=e,this.key=t,this.options=r}setUnprotectedHeader(e){if(this.unprotectedHeader)throw TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=e,this}addRecipient(...e){return this.parent.addRecipient(...e)}encrypt(...e){return this.parent.encrypt(...e)}done(){return this.parent}}class eY{_plaintext;_recipients=[];_protectedHeader;_unprotectedHeader;_aad;constructor(e){this._plaintext=e}addRecipient(e,t){let r=new eq(this,e,{crit:t?.crit});return this._recipients.push(r),r}setProtectedHeader(e){if(this._protectedHeader)throw TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setSharedUnprotectedHeader(e){if(this._unprotectedHeader)throw TypeError("setSharedUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}setAdditionalAuthenticatedData(e){return this._aad=e,this}async encrypt(){let e;if(!this._recipients.length)throw new b("at least one recipient must be added");if(1===this._recipients.length){let[e]=this._recipients,t=await new eX(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(e.unprotectedHeader).encrypt(e.key,{...e.options}),r={ciphertext:t.ciphertext,iv:t.iv,recipients:[{}],tag:t.tag};return t.aad&&(r.aad=t.aad),t.protected&&(r.protected=t.protected),t.unprotected&&(r.unprotected=t.unprotected),t.encrypted_key&&(r.recipients[0].encrypted_key=t.encrypted_key),t.header&&(r.recipients[0].header=t.header),r}for(let t=0;t<this._recipients.length;t++){let r=this._recipients[t];if(!Z(this._protectedHeader,this._unprotectedHeader,r.unprotectedHeader))throw new b("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");let a={...this._protectedHeader,...this._unprotectedHeader,...r.unprotectedHeader},{alg:i}=a;if("string"!=typeof i||!i)throw new b('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("dir"===i||"ECDH-ES"===i)throw new b('"dir" and "ECDH-ES" alg may only be used with a single recipient');if("string"!=typeof a.enc||!a.enc)throw new b('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');if(e){if(e!==a.enc)throw new b('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients')}else e=a.enc;if(ej(b,new Map,r.options.crit,this._protectedHeader,a),void 0!==a.zip)throw new S('JWE "zip" (Compression Algorithm) Header Parameter is not supported.')}let t=ev(e),r={ciphertext:"",iv:"",recipients:[],tag:""};for(let a=0;a<this._recipients.length;a++){let i=this._recipients[a],n={};r.recipients.push(n);let o=({...this._protectedHeader,...this._unprotectedHeader,...i.unprotectedHeader}).alg.startsWith("PBES2")?2048+a:void 0;if(0===a){let e=await new eX(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(t).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(i.unprotectedHeader).setKeyManagementParameters({p2c:o}).encrypt(i.key,{...i.options,[eG]:!0});r.ciphertext=e.ciphertext,r.iv=e.iv,r.tag=e.tag,e.aad&&(r.aad=e.aad),e.protected&&(r.protected=e.protected),e.unprotected&&(r.unprotected=e.unprotected),n.encrypted_key=e.encrypted_key,e.header&&(n.header=e.header);continue}let{encryptedKey:s,parameters:c}=await ez(i.unprotectedHeader?.alg||this._protectedHeader?.alg||this._unprotectedHeader?.alg,e,i.key,t,{p2c:o});n.encrypted_key=y(s),(i.unprotectedHeader||c)&&(n.header={...i.unprotectedHeader,...c})}return r}}function eQ(e){switch(e){case"PS256":case"RS256":case"ES256":case"ES256K":return"sha256";case"PS384":case"RS384":case"ES384":return"sha384";case"PS512":case"RS512":case"ES512":return"sha512";case"Ed25519":case"EdDSA":return;default:throw new S(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}let eZ=new Map([["ES256","P-256"],["ES256K","secp256k1"],["ES384","P-384"],["ES512","P-521"]]);function e2(e,t){let r,a,n,o;if(t instanceof i.KeyObject)r=t.asymmetricKeyType,a=t.asymmetricKeyDetails;else switch(n=!0,t.kty){case"RSA":r="rsa";break;case"EC":r="ec";break;case"OKP":if("Ed25519"===t.crv){r="ed25519";break}if("Ed448"===t.crv){r="ed448";break}throw TypeError("Invalid key for this operation, its crv must be Ed25519 or Ed448");default:throw TypeError("Invalid key for this operation, its kty must be RSA, OKP, or EC")}switch(e){case"Ed25519":if("ed25519"!==r)throw TypeError("Invalid key for this operation, its asymmetricKeyType must be ed25519");break;case"EdDSA":if(!["ed25519","ed448"].includes(r))throw TypeError("Invalid key for this operation, its asymmetricKeyType must be ed25519 or ed448");break;case"RS256":case"RS384":case"RS512":if("rsa"!==r)throw TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa");ew(t,e);break;case"PS256":case"PS384":case"PS512":if("rsa-pss"===r){let{hashAlgorithm:t,mgf1HashAlgorithm:r,saltLength:i}=a,n=parseInt(e.slice(-3),10);if(void 0!==t&&(t!==`sha${n}`||r!==t))throw TypeError(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${e}`);if(void 0!==i&&i>n>>3)throw TypeError(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${e}`)}else if("rsa"!==r)throw TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa or rsa-pss");ew(t,e),o={padding:i.constants.RSA_PKCS1_PSS_PADDING,saltLength:i.constants.RSA_PSS_SALTLEN_DIGEST};break;case"ES256":case"ES256K":case"ES384":case"ES512":{if("ec"!==r)throw TypeError("Invalid key for this operation, its asymmetricKeyType must be ec");let a=eo(t),i=eZ.get(e);if(a!==i)throw TypeError(`Invalid key curve for the algorithm, its curve must be ${i}, got ${a}`);o={dsaEncoding:"ieee-p1363"};break}default:throw new S(`alg ${e} is not supported either by JOSE or your javascript runtime`)}return n?{format:"jwk",key:t,...o}:o?{...o,key:t}:t}function e0(e,t,r){if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw TypeError(V(t,...Y));return(0,i.createSecretKey)(t)}if(t instanceof i.KeyObject)return t;if(M(t))return!function(e,t,...r){switch(t){case"HS256":case"HS384":case"HS512":{if(!$(e.algorithm,"HMAC"))throw N("HMAC");let r=parseInt(t.slice(2),10);if(B(e.algorithm.hash)!==r)throw N(`SHA-${r}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!$(e.algorithm,"RSASSA-PKCS1-v1_5"))throw N("RSASSA-PKCS1-v1_5");let r=parseInt(t.slice(2),10);if(B(e.algorithm.hash)!==r)throw N(`SHA-${r}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!$(e.algorithm,"RSA-PSS"))throw N("RSA-PSS");let r=parseInt(t.slice(2),10);if(B(e.algorithm.hash)!==r)throw N(`SHA-${r}`,"algorithm.hash");break}case"EdDSA":if("Ed25519"!==e.algorithm.name&&"Ed448"!==e.algorithm.name)throw N("Ed25519 or Ed448");break;case"Ed25519":if(!$(e.algorithm,"Ed25519"))throw N("Ed25519");break;case"ES256":case"ES384":case"ES512":{if(!$(e.algorithm,"ECDSA"))throw N("ECDSA");let r=function(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw Error("unreachable")}}(t);if(e.algorithm.namedCurve!==r)throw N(r,"algorithm.namedCurve");break}default:throw TypeError("CryptoKey does not support this operation")}G(e,r)}(t,e,r),i.KeyObject.from(t);if(en(t))return e.startsWith("HS")?(0,i.createSecretKey)(Buffer.from(t.k,"base64url")):t;throw TypeError(V(t,...Y,"Uint8Array","JSON Web Key"))}let e1=(0,R.promisify)(i.sign),e5=async(e,t,r)=>{let a=e0(e,t,"sign");if(e.startsWith("HS")){let t=i.createHmac(function(e){switch(e){case"HS256":return"sha256";case"HS384":return"sha384";case"HS512":return"sha512";default:throw new S(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}(e),a);return t.update(r),t.digest()}return e1(eQ(e),r,e2(e,a))},e8=(0,R.promisify)(i.verify),e4=async(e,t,r,a)=>{let n=e0(e,t,"verify");if(e.startsWith("HS")){let t=await e5(e,n,a);try{return i.timingSafeEqual(r,t)}catch{return!1}}let o=eQ(e),s=e2(e,n);try{return await e8(o,a,s,r)}catch{return!1}};async function e6(e,t,r){let a,i;if(!ee(e))throw new A("Flattened JWS must be an object");if(void 0===e.protected&&void 0===e.header)throw new A('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==e.protected&&"string"!=typeof e.protected)throw new A("JWS Protected Header incorrect type");if(void 0===e.payload)throw new A("JWS Payload missing");if("string"!=typeof e.signature)throw new A("JWS Signature missing or incorrect type");if(void 0!==e.header&&!ee(e.header))throw new A("JWS Unprotected Header incorrect type");let n={};if(e.protected)try{let t=f(e.protected);n=JSON.parse(s.decode(t))}catch{throw new A("JWS Protected Header is invalid")}if(!Z(n,e.header))throw new A("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");let d={...n,...e.header},p=ej(A,new Map([["b64",!0]]),r?.crit,n,d),l=!0;if(p.has("b64")&&"boolean"!=typeof(l=n.b64))throw new A('The "b64" (base64url-encode payload) Header Parameter must be a boolean');let{alg:h}=d;if("string"!=typeof h||!h)throw new A('JWS "alg" (Algorithm) Header Parameter missing or invalid');let u=r&&eM("algorithms",r.algorithms);if(u&&!u.has(h))throw new g('"alg" (Algorithm) Header Parameter value not allowed');if(l){if("string"!=typeof e.payload)throw new A("JWS Payload must be a string")}else if("string"!=typeof e.payload&&!(e.payload instanceof Uint8Array))throw new A("JWS Payload must be a string or an Uint8Array instance");let y=!1;"function"==typeof t?(t=await t(n,e),y=!0,eR(h,t,"verify"),en(t)&&(t=await eW(t,h))):eR(h,t,"verify");let w=c(o.encode(e.protected??""),o.encode("."),"string"==typeof e.payload?o.encode(e.payload):e.payload);try{a=f(e.signature)}catch{throw new A("Failed to base64url decode the signature")}if(!await e4(h,t,a,w))throw new J;if(l)try{i=f(e.payload)}catch{throw new A("Failed to base64url decode the payload")}else i="string"==typeof e.payload?o.encode(e.payload):e.payload;let m={payload:i};return(void 0!==e.protected&&(m.protectedHeader=n),void 0!==e.header&&(m.unprotectedHeader=e.header),y)?{...m,key:t}:m}async function e3(e,t,r){if(e instanceof Uint8Array&&(e=s.decode(e)),"string"!=typeof e)throw new A("Compact JWS must be a string or Uint8Array");let{0:a,1:i,2:n,length:o}=e.split(".");if(3!==o)throw new A("Invalid Compact JWS");let c=await e6({payload:i,protected:a,signature:n},t,r),d={payload:c.payload,protectedHeader:c.protectedHeader};return"function"==typeof t?{...d,key:c.key}:d}async function e9(e,t,r){if(!ee(e))throw new A("General JWS must be an object");if(!Array.isArray(e.signatures)||!e.signatures.every(ee))throw new A("JWS Signatures missing or incorrect type");for(let a of e.signatures)try{return await e6({header:a.header,payload:e.payload,protected:a.protected,signature:a.signature},t,r)}catch{}throw new J}let e7=e=>Math.floor(e.getTime()/1e3),te=/^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i,tt=e=>{let t,r=te.exec(e);if(!r||r[4]&&r[1])throw TypeError("Invalid time period format");let a=parseFloat(r[2]);switch(r[3].toLowerCase()){case"sec":case"secs":case"second":case"seconds":case"s":t=Math.round(a);break;case"minute":case"minutes":case"min":case"mins":case"m":t=Math.round(60*a);break;case"hour":case"hours":case"hr":case"hrs":case"h":t=Math.round(3600*a);break;case"day":case"days":case"d":t=Math.round(86400*a);break;case"week":case"weeks":case"w":t=Math.round(604800*a);break;default:t=Math.round(0x1e187e0*a)}return"-"===r[1]||"ago"===r[4]?-t:t},tr=e=>e.toLowerCase().replace(/^application\//,""),ta=(e,t,r={})=>{let a,i;try{a=JSON.parse(s.decode(t))}catch{}if(!ee(a))throw new v("JWT Claims Set must be a top-level JSON object");let{typ:n}=r;if(n&&("string"!=typeof e.typ||tr(e.typ)!==tr(n)))throw new m('unexpected "typ" JWT header value',a,"typ","check_failed");let{requiredClaims:o=[],issuer:c,subject:d,audience:p,maxTokenAge:l}=r,h=[...o];for(let e of(void 0!==l&&h.push("iat"),void 0!==p&&h.push("aud"),void 0!==d&&h.push("sub"),void 0!==c&&h.push("iss"),new Set(h.reverse())))if(!(e in a))throw new m(`missing required "${e}" claim`,a,e,"missing");if(c&&!(Array.isArray(c)?c:[c]).includes(a.iss))throw new m('unexpected "iss" claim value',a,"iss","check_failed");if(d&&a.sub!==d)throw new m('unexpected "sub" claim value',a,"sub","check_failed");if(p&&!((e,t)=>"string"==typeof e?t.includes(e):!!Array.isArray(e)&&t.some(Set.prototype.has.bind(new Set(e))))(a.aud,"string"==typeof p?[p]:p))throw new m('unexpected "aud" claim value',a,"aud","check_failed");switch(typeof r.clockTolerance){case"string":i=tt(r.clockTolerance);break;case"number":i=r.clockTolerance;break;case"undefined":i=0;break;default:throw TypeError("Invalid clockTolerance option type")}let{currentDate:u}=r,y=e7(u||new Date);if((void 0!==a.iat||l)&&"number"!=typeof a.iat)throw new m('"iat" claim must be a number',a,"iat","invalid");if(void 0!==a.nbf){if("number"!=typeof a.nbf)throw new m('"nbf" claim must be a number',a,"nbf","invalid");if(a.nbf>y+i)throw new m('"nbf" claim timestamp check failed',a,"nbf","check_failed")}if(void 0!==a.exp){if("number"!=typeof a.exp)throw new m('"exp" claim must be a number',a,"exp","invalid");if(a.exp<=y-i)throw new E('"exp" claim timestamp check failed',a,"exp","check_failed")}if(l){let e=y-a.iat;if(e-i>("number"==typeof l?l:tt(l)))throw new E('"iat" claim timestamp check failed (too far in the past)',a,"iat","check_failed");if(e<0-i)throw new m('"iat" claim timestamp check failed (it should be in the past)',a,"iat","check_failed")}return a};async function ti(e,t,r){let a=await e3(e,t,r);if(a.protectedHeader.crit?.includes("b64")&&!1===a.protectedHeader.b64)throw new v("JWTs MUST NOT use unencoded payload");let i={payload:ta(a.protectedHeader,a.payload,r),protectedHeader:a.protectedHeader};return"function"==typeof t?{...i,key:a.key}:i}async function tn(e,t,r){let a=await e$(e,t,r),i=ta(a.protectedHeader,a.plaintext,r),{protectedHeader:n}=a;if(void 0!==n.iss&&n.iss!==i.iss)throw new m('replicated "iss" claim header parameter mismatch',i,"iss","mismatch");if(void 0!==n.sub&&n.sub!==i.sub)throw new m('replicated "sub" claim header parameter mismatch',i,"sub","mismatch");if(void 0!==n.aud&&JSON.stringify(n.aud)!==JSON.stringify(i.aud))throw new m('replicated "aud" claim header parameter mismatch',i,"aud","mismatch");let o={payload:i,protectedHeader:n};return"function"==typeof t?{...o,key:a.key}:o}class to{_flattened;constructor(e){this._flattened=new eX(e)}setContentEncryptionKey(e){return this._flattened.setContentEncryptionKey(e),this}setInitializationVector(e){return this._flattened.setInitializationVector(e),this}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}setKeyManagementParameters(e){return this._flattened.setKeyManagementParameters(e),this}async encrypt(e,t){let r=await this._flattened.encrypt(e,t);return[r.protected,r.encrypted_key,r.iv,r.ciphertext,r.tag].join(".")}}class ts{_payload;_protectedHeader;_unprotectedHeader;constructor(e){if(!(e instanceof Uint8Array))throw TypeError("payload must be an instance of Uint8Array");this._payload=e}setProtectedHeader(e){if(this._protectedHeader)throw TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}async sign(e,t){let r;if(!this._protectedHeader&&!this._unprotectedHeader)throw new A("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!Z(this._protectedHeader,this._unprotectedHeader))throw new A("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");let a={...this._protectedHeader,...this._unprotectedHeader},i=ej(A,new Map([["b64",!0]]),t?.crit,this._protectedHeader,a),n=!0;if(i.has("b64")&&"boolean"!=typeof(n=this._protectedHeader.b64))throw new A('The "b64" (base64url-encode payload) Header Parameter must be a boolean');let{alg:d}=a;if("string"!=typeof d||!d)throw new A('JWS "alg" (Algorithm) Header Parameter missing or invalid');eR(d,e,"sign");let p=this._payload;n&&(p=o.encode(y(p)));let l=c(r=this._protectedHeader?o.encode(y(JSON.stringify(this._protectedHeader))):o.encode(""),o.encode("."),p),h={signature:y(await e5(d,e,l)),payload:""};return n&&(h.payload=s.decode(p)),this._unprotectedHeader&&(h.header=this._unprotectedHeader),this._protectedHeader&&(h.protected=s.decode(r)),h}}class tc{_flattened;constructor(e){this._flattened=new ts(e)}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}async sign(e,t){let r=await this._flattened.sign(e,t);if(void 0===r.payload)throw TypeError("use the flattened module for creating JWS with b64: false");return`${r.protected}.${r.payload}.${r.signature}`}}class td{parent;protectedHeader;unprotectedHeader;options;key;constructor(e,t,r){this.parent=e,this.key=t,this.options=r}setProtectedHeader(e){if(this.protectedHeader)throw TypeError("setProtectedHeader can only be called once");return this.protectedHeader=e,this}setUnprotectedHeader(e){if(this.unprotectedHeader)throw TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=e,this}addSignature(...e){return this.parent.addSignature(...e)}sign(...e){return this.parent.sign(...e)}done(){return this.parent}}class tp{_payload;_signatures=[];constructor(e){this._payload=e}addSignature(e,t){let r=new td(this,e,t);return this._signatures.push(r),r}async sign(){if(!this._signatures.length)throw new A("at least one signature must be added");let e={signatures:[],payload:""};for(let t=0;t<this._signatures.length;t++){let r=this._signatures[t],a=new ts(this._payload);a.setProtectedHeader(r.protectedHeader),a.setUnprotectedHeader(r.unprotectedHeader);let{payload:i,...n}=await a.sign(r.key,r.options);if(0===t)e.payload=i;else if(e.payload!==i)throw new A("inconsistent use of JWS Unencoded Payload (RFC7797)");e.signatures.push(n)}return e}}function tl(e,t){if(!Number.isFinite(t))throw TypeError(`Invalid ${e} input`);return t}class th{_payload;constructor(e={}){if(!ee(e))throw TypeError("JWT Claims Set MUST be an object");this._payload=e}setIssuer(e){return this._payload={...this._payload,iss:e},this}setSubject(e){return this._payload={...this._payload,sub:e},this}setAudience(e){return this._payload={...this._payload,aud:e},this}setJti(e){return this._payload={...this._payload,jti:e},this}setNotBefore(e){return"number"==typeof e?this._payload={...this._payload,nbf:tl("setNotBefore",e)}:e instanceof Date?this._payload={...this._payload,nbf:tl("setNotBefore",e7(e))}:this._payload={...this._payload,nbf:e7(new Date)+tt(e)},this}setExpirationTime(e){return"number"==typeof e?this._payload={...this._payload,exp:tl("setExpirationTime",e)}:e instanceof Date?this._payload={...this._payload,exp:tl("setExpirationTime",e7(e))}:this._payload={...this._payload,exp:e7(new Date)+tt(e)},this}setIssuedAt(e){return void 0===e?this._payload={...this._payload,iat:e7(new Date)}:e instanceof Date?this._payload={...this._payload,iat:tl("setIssuedAt",e7(e))}:"string"==typeof e?this._payload={...this._payload,iat:tl("setIssuedAt",e7(new Date)+tt(e))}:this._payload={...this._payload,iat:tl("setIssuedAt",e)},this}}class tu extends th{_protectedHeader;setProtectedHeader(e){return this._protectedHeader=e,this}async sign(e,t){let r=new tc(o.encode(JSON.stringify(this._payload)));if(r.setProtectedHeader(this._protectedHeader),Array.isArray(this._protectedHeader?.crit)&&this._protectedHeader.crit.includes("b64")&&!1===this._protectedHeader.b64)throw new v("JWTs MUST NOT use unencoded payload");return r.sign(e,t)}}class ty extends th{_cek;_iv;_keyManagementParameters;_protectedHeader;_replicateIssuerAsHeader;_replicateSubjectAsHeader;_replicateAudienceAsHeader;setProtectedHeader(e){if(this._protectedHeader)throw TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setKeyManagementParameters(e){if(this._keyManagementParameters)throw TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=e,this}setContentEncryptionKey(e){if(this._cek)throw TypeError("setContentEncryptionKey can only be called once");return this._cek=e,this}setInitializationVector(e){if(this._iv)throw TypeError("setInitializationVector can only be called once");return this._iv=e,this}replicateIssuerAsHeader(){return this._replicateIssuerAsHeader=!0,this}replicateSubjectAsHeader(){return this._replicateSubjectAsHeader=!0,this}replicateAudienceAsHeader(){return this._replicateAudienceAsHeader=!0,this}async encrypt(e,t){let r=new to(o.encode(JSON.stringify(this._payload)));return this._replicateIssuerAsHeader&&(this._protectedHeader={...this._protectedHeader,iss:this._payload.iss}),this._replicateSubjectAsHeader&&(this._protectedHeader={...this._protectedHeader,sub:this._payload.sub}),this._replicateAudienceAsHeader&&(this._protectedHeader={...this._protectedHeader,aud:this._payload.aud}),r.setProtectedHeader(this._protectedHeader),this._iv&&r.setInitializationVector(this._iv),this._cek&&r.setContentEncryptionKey(this._cek),this._keyManagementParameters&&r.setKeyManagementParameters(this._keyManagementParameters),r.encrypt(e,t)}}let tf=(e,t)=>{if("string"!=typeof e||!e)throw new H(`${t} missing or invalid`)};async function tw(e,t){let r;if(!ee(e))throw TypeError("JWK must be an object");if("sha256"!==(t??="sha256")&&"sha384"!==t&&"sha512"!==t)throw TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');switch(e.kty){case"EC":tf(e.crv,'"crv" (Curve) Parameter'),tf(e.x,'"x" (X Coordinate) Parameter'),tf(e.y,'"y" (Y Coordinate) Parameter'),r={crv:e.crv,kty:e.kty,x:e.x,y:e.y};break;case"OKP":tf(e.crv,'"crv" (Subtype of Key Pair) Parameter'),tf(e.x,'"x" (Public Key) Parameter'),r={crv:e.crv,kty:e.kty,x:e.x};break;case"RSA":tf(e.e,'"e" (Exponent) Parameter'),tf(e.n,'"n" (Modulus) Parameter'),r={e:e.e,kty:e.kty,n:e.n};break;case"oct":tf(e.k,'"k" (Key Value) Parameter'),r={k:e.k,kty:e.kty};break;default:throw new S('"kty" (Key Type) Parameter missing or unsupported')}let a=o.encode(JSON.stringify(r));return y(await n(t,a))}async function tm(e,t){t??="sha256";let r=await tw(e,t);return`urn:ietf:params:oauth:jwk-thumbprint:sha-${t.slice(-3)}:${r}`}async function tE(e,t){let r={...e,...t?.header};if(!ee(r.jwk))throw new A('"jwk" (JSON Web Key) Header Parameter must be a JSON object');let a=await eW({...r.jwk,ext:!0},r.alg);if(a instanceof Uint8Array||"public"!==a.type)throw new A('"jwk" (JSON Web Key) Header Parameter must be a public key');return a}function tg(e){return ee(e)}function tS(e){return"function"==typeof structuredClone?structuredClone(e):JSON.parse(JSON.stringify(e))}class t_{_jwks;_cached=new WeakMap;constructor(e){if(!function(e){return e&&"object"==typeof e&&Array.isArray(e.keys)&&e.keys.every(tg)}(e))throw new k("JSON Web Key Set malformed");this._jwks=tS(e)}async getKey(e,t){let{alg:r,kid:a}={...e,...t?.header},i=function(e){switch("string"==typeof e&&e.slice(0,2)){case"RS":case"PS":return"RSA";case"ES":return"EC";case"Ed":return"OKP";default:throw new S('Unsupported "alg" value for a JSON Web Key Set')}}(r),n=this._jwks.keys.filter(e=>{let t=i===e.kty;if(t&&"string"==typeof a&&(t=a===e.kid),t&&"string"==typeof e.alg&&(t=r===e.alg),t&&"string"==typeof e.use&&(t="sig"===e.use),t&&Array.isArray(e.key_ops)&&(t=e.key_ops.includes("verify")),t)switch(r){case"ES256":t="P-256"===e.crv;break;case"ES256K":t="secp256k1"===e.crv;break;case"ES384":t="P-384"===e.crv;break;case"ES512":t="P-521"===e.crv;break;case"Ed25519":t="Ed25519"===e.crv;break;case"EdDSA":t="Ed25519"===e.crv||"Ed448"===e.crv}return t}),{0:o,length:s}=n;if(0===s)throw new P;if(1!==s){let e=new K,{_cached:t}=this;throw e[Symbol.asyncIterator]=async function*(){for(let e of n)try{yield await tb(t,e,r)}catch{}},e}return tb(this._cached,o,r)}}async function tb(e,t,r){let a=e.get(t)||e.set(t,{}).get(t);if(void 0===a[r]){let e=await eW({...t,ext:!0},r);if(e instanceof Uint8Array||"public"!==e.type)throw new k("JSON Web Key Set members must be public keys");a[r]=e}return a[r]}function tA(e){let t=new t_(e),r=async(e,r)=>t.getKey(e,r);return Object.defineProperties(r,{jwks:{value:()=>tS(t._jwks),enumerable:!0,configurable:!1,writable:!1}}),r}var tv=e.i(47299),tH=e.i(43698),tk=e.i(87769);let tP=async(e,t,r)=>{let a;switch(e.protocol){case"https:":a=tH.get;break;case"http:":a=tv.get;break;default:throw TypeError("Unsupported URL protocol.")}let{agent:i,headers:n}=r,o=a(e.href,{agent:i,timeout:t,headers:n}),[d]=await Promise.race([(0,tk.once)(o,"response"),(0,tk.once)(o,"timeout")]);if(!d)throw o.destroy(),new W;if(200!==d.statusCode)throw new w("Expected 200 OK from the JSON Web Key Set HTTP response");let p=[];for await(let e of d)p.push(e);try{return JSON.parse(s.decode(c(...p)))}catch{throw new w("Failed to parse the JSON Web Key Set HTTP response as JSON")}};"undefined"!=typeof navigator&&navigator.userAgent?.startsWith?.("Mozilla/5.0 ")||(r="jose/v5.10.0");let tK=Symbol();class tW{_url;_timeoutDuration;_cooldownDuration;_cacheMaxAge;_jwksTimestamp;_pendingFetch;_options;_local;_cache;constructor(e,t){if(!(e instanceof URL))throw TypeError("url must be an instance of URL");this._url=new URL(e.href),this._options={agent:t?.agent,headers:t?.headers},this._timeoutDuration="number"==typeof t?.timeoutDuration?t?.timeoutDuration:5e3,this._cooldownDuration="number"==typeof t?.cooldownDuration?t?.cooldownDuration:3e4,this._cacheMaxAge="number"==typeof t?.cacheMaxAge?t?.cacheMaxAge:6e5,t?.[tK]!==void 0&&(this._cache=t?.[tK],function(e,t){return!("object"!=typeof e||null===e||!("uat"in e)||"number"!=typeof e.uat||Date.now()-e.uat>=t)&&"jwks"in e&&!!ee(e.jwks)&&!!Array.isArray(e.jwks.keys)&&!!Array.prototype.every.call(e.jwks.keys,ee)}(t?.[tK],this._cacheMaxAge)&&(this._jwksTimestamp=this._cache.uat,this._local=tA(this._cache.jwks)))}coolingDown(){return"number"==typeof this._jwksTimestamp&&Date.now()<this._jwksTimestamp+this._cooldownDuration}fresh(){return"number"==typeof this._jwksTimestamp&&Date.now()<this._jwksTimestamp+this._cacheMaxAge}async getKey(e,t){this._local&&this.fresh()||await this.reload();try{return await this._local(e,t)}catch(r){if(r instanceof P&&!1===this.coolingDown())return await this.reload(),this._local(e,t);throw r}}async reload(){this._pendingFetch&&("undefined"!=typeof WebSocketPair||"undefined"!=typeof navigator&&"Cloudflare-Workers"===navigator.userAgent||"undefined"!=typeof EdgeRuntime&&"vercel"===EdgeRuntime)&&(this._pendingFetch=void 0);let e=new Headers(this._options.headers);r&&!e.has("User-Agent")&&(e.set("User-Agent",r),this._options.headers=Object.fromEntries(e.entries())),this._pendingFetch||=tP(this._url,this._timeoutDuration,this._options).then(e=>{this._local=tA(e),this._cache&&(this._cache.uat=Date.now(),this._cache.jwks=e),this._jwksTimestamp=Date.now(),this._pendingFetch=void 0}).catch(e=>{throw this._pendingFetch=void 0,e}),await this._pendingFetch}}function tJ(e,t){let r=new tW(e,t),a=async(e,t)=>r.getKey(e,t);return Object.defineProperties(a,{coolingDown:{get:()=>r.coolingDown(),enumerable:!0,configurable:!1},fresh:{get:()=>r.fresh(),enumerable:!0,configurable:!1},reload:{value:()=>r.reload(),enumerable:!0,configurable:!1,writable:!1},reloading:{get:()=>!!r._pendingFetch,enumerable:!0,configurable:!1},jwks:{value:()=>r._local?.jwks(),enumerable:!0,configurable:!1,writable:!1}}),a}let tT=tK;class tC extends th{encode(){let e=y(JSON.stringify({alg:"none"})),t=y(JSON.stringify(this._payload));return`${e}.${t}.`}static decode(e,t){let r;if("string"!=typeof e)throw new v("Unsecured JWT must be a string");let{0:a,1:i,2:n,length:o}=e.split(".");if(3!==o||""!==n)throw new v("Invalid Unsecured JWT");try{if(r=JSON.parse(s.decode(f(a))),"none"!==r.alg)throw Error()}catch{throw new v("Invalid Unsecured JWT")}return{payload:ta(r,f(i),t),header:r}}}e.s(["decode",()=>tR,"encode",()=>tI],88201);let tI=y,tR=f;function tO(e){let t;if("string"==typeof e){let r=e.split(".");(3===r.length||5===r.length)&&([t]=r)}else if("object"==typeof e&&e)if("protected"in e)t=e.protected;else throw TypeError("Token does not contain a Protected Header");try{if("string"!=typeof t||!t)throw Error();let e=JSON.parse(s.decode(tR(t)));if(!ee(e))throw Error();return e}catch{throw TypeError("Invalid Token or Protected Header formatting")}}function tx(e){let t,r;if("string"!=typeof e)throw new v("JWTs must use Compact JWS serialization, JWT must be a string");let{1:a,length:i}=e.split(".");if(5===i)throw new v("Only JWTs using Compact JWS serialization can be decoded");if(3!==i)throw new v("Invalid JWT");if(!a)throw new v("JWTs must contain a payload");try{t=tR(a)}catch{throw new v("Failed to base64url decode the payload")}try{r=JSON.parse(s.decode(t))}catch{throw new v("Failed to parse the decoded payload as JSON")}if(!ee(r))throw new v("Invalid JWT Claims Set");return r}var tU=e.i(1842),T=i;let tD=(0,R.promisify)(i.generateKeyPair);async function tj(e,t){let r;switch(e){case"HS256":case"HS384":case"HS512":case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":r=parseInt(e.slice(-3),10);break;case"A128KW":case"A192KW":case"A256KW":case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":case"A128GCM":case"A192GCM":case"A256GCM":r=parseInt(e.slice(1,4),10);break;default:throw new S('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return(0,i.createSecretKey)((0,T.randomFillSync)(new Uint8Array(r>>3)))}async function tM(e,t){switch(e){case"RS256":case"RS384":case"RS512":case"PS256":case"PS384":case"PS512":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":case"RSA1_5":{let e=t?.modulusLength??2048;if("number"!=typeof e||e<2048)throw new S("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");return await tD("rsa",{modulusLength:e,publicExponent:65537})}case"ES256":return tD("ec",{namedCurve:"P-256"});case"ES256K":return tD("ec",{namedCurve:"secp256k1"});case"ES384":return tD("ec",{namedCurve:"P-384"});case"ES512":return tD("ec",{namedCurve:"P-521"});case"Ed25519":return tD("ed25519");case"EdDSA":switch(t?.crv){case void 0:case"Ed25519":return tD("ed25519");case"Ed448":return tD("ed448");default:throw new S("Invalid or unsupported crv option provided, supported values are Ed25519 and Ed448")}case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{let e=t?.crv??"P-256";switch(e){case void 0:case"P-256":case"P-384":case"P-521":return tD("ec",{namedCurve:e});case"X25519":return tD("x25519");case"X448":return tD("x448");default:throw new S("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448")}}default:throw new S('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}}async function tN(e,t){return tM(e,t)}async function t$(e,t){return tj(e,t)}var tB=e.i(88201);let tG="node:crypto"}];

//# sourceMappingURL=%5Broot-of-the-server%5D__b7c7cb27._.js.map